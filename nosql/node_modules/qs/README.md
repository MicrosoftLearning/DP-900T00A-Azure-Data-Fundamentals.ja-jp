---
ms.openlocfilehash: 334cc21b44dad92ee91fd1f8a2aaf91f242cea2e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052755"
---
# <a name="qs-supversion-badge21sup"></a>qs <sup>[![バージョン バッジ][2]][1]</sup>

[![ビルドの状態][3]][4]
[![依存関係の状態][5]][6]
[![開発の依存関係の状態][7]][8]
[![ライセンス][license-image]][license-url]
[![ダウンロード][downloads-image]][downloads-url]

[![npm バッジ][11]][1]

セキュリティが強化されたクエリ文字列の解析および文字列化ライブラリ。

リード メンテナー: [Jordan Harband](https://github.com/ljharb)

**qs** モジュールは、当初、[TJ Holowaychuk](https://github.com/visionmedia/node-querystring)によって作成され保守されていました。

## <a name="usage"></a>使用

```javascript
var qs = require('qs');
var assert = require('assert');

var obj = qs.parse('a=c');
assert.deepEqual(obj, { a: 'c' });

var str = qs.stringify(obj);
assert.equal(str, 'a=c');
```

### <a name="parsing-objects"></a>オブジェクトの解析

[](#preventEval)
```javascript
qs.parse(string, [options]);
```

**qs** を使用すると、サブキーの名前を角かっこ `[]` で囲むことにより、クエリ文字列内に入れ子になったオブジェクトを作成できます。
たとえば、文字列 `'foo[bar]=baz'` は次のように変換されます。

```javascript
assert.deepEqual(qs.parse('foo[bar]=baz'), {
    foo: {
        bar: 'baz'
    }
});
```

`plainObjects` オプションを使用すると、解析された値は、`Object.create(null)` を介して作成された null オブジェクトとして返されます。そのため、プロトタイプ メソッドは存在せず、ユーザーはこれらの名前を任意の値に設定できることに注意してください。

```javascript
var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });
assert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });
```

既定では、オブジェクトのプロトタイプのプロパティを上書きするパラメーターは無視されます。これらのフィールドのデータを保持する場合は、上記のように、`plainObjects` を使用するか、`allowPrototypes` を `true`に設定してユーザー入力でこれらのプロパティを上書きできるようにします。 "*警告*" 上書きされたプロパティを使用しようとすると問題が発生する可能性があるため、通常は、このオプションを有効にすることはお勧めできません。 このオプションには常に注意してください。

```javascript
var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });
assert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });
```

URI でエンコードされた文字列も機能します。

```javascript
assert.deepEqual(qs.parse('a%5Bb%5D=c'), {
    a: { b: 'c' }
});
```

さらに、`'foo[bar][baz]=foobarbaz'` のように、オブジェクトを入れ子にすることもできます。

```javascript
assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {
    foo: {
        bar: {
            baz: 'foobarbaz'
        }
    }
});
```

既定では、オブジェクトを入れ子にした場合、**qs** では、最大 5 つの子の深さまでしか解析されません。 つまり、`'a[b][c][d][e][f][g][h][i]=j'` のような文字列を解析しようとすると、結果として生成されるオブジェクトは次のようになります。

```javascript
var expected = {
    a: {
        b: {
            c: {
                d: {
                    e: {
                        f: {
                            '[g][h][i]': 'j'
                        }
                    }
                }
            }
        }
    }
};
var string = 'a[b][c][d][e][f][g][h][i]=j';
assert.deepEqual(qs.parse(string), expected);
```

この深さは、`depth` オプションを `qs.parse(string, [options])` に渡すことによってオーバーライドできます。

```javascript
var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });
assert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });
```

深さの制限は、**qs** を使用してユーザー入力を解析する場合に不正使用を軽減するのに役立つため、妥当な数に抑えることをお勧めします。

同様の理由から、既定では、**qs** で解析されるパラメーターは最大 1,000 個までです。 これは、`parameterLimit` オプションを渡すことによってオーバーライドできます。

```javascript
var limited = qs.parse('a=b&c=d', { parameterLimit: 1 });
assert.deepEqual(limited, { a: 'b' });
```

先頭の疑問符をバイパスするには、`ignoreQueryPrefix` を使用します。

```javascript
var prefixed = qs.parse('?a=b&c=d', { ignoreQueryPrefix: true });
assert.deepEqual(prefixed, { a: 'b', c: 'd' });
```

オプションの区切り記号を渡すこともできます。

```javascript
var delimited = qs.parse('a=b;c=d', { delimiter: ';' });
assert.deepEqual(delimited, { a: 'b', c: 'd' });
```

区切り記号として正規表現を指定することもできます。

```javascript
var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });
assert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });
```

オプション `allowDots` を使用してドット表記を有効にすることができます。

```javascript
var withDots = qs.parse('a.b=c', { allowDots: true });
assert.deepEqual(withDots, { a: { b: 'c' } });
```

従来のブラウザーまたはサービスに対処する必要がある場合、パーセントでエンコードされたオクテットを iso-8859-1 としてデコードするためのサポートもあります。

```javascript
var oldCharset = qs.parse('a=%A7', { charset: 'iso-8859-1' });
assert.deepEqual(oldCharset, { a: '§' });
```

一部のサービスでは、Internet Explorer の古いバージョンでフォームを utf-8 として送信する可能性を高めるために、初期値 `utf8=✓` がフォームに追加されます。 さらに、サーバーでは、チェックマーク文字の誤ったエンコードに対して値をチェックし、クエリ文字列または `application/x-www-form-urlencoded` 本文が、utf-8 として送信され *なかった* ことを検出できます (たとえば、フォームに `accept-charset` パラメーターが含まれているか、含まれているページに別の文字セットが含まれている場合など)。

**qs** では、`charsetSentinel` オプションを使用して、このメカニズムをサポートします。
指定した場合、`utf8` パラメーターが、返されるオブジェクトから省略されます。 これは、チェックマークのエンコード方法に応じて、`iso-8859-1`/`utf-8` モードに切り替えるために使用されます。

**重要**: `charset` オプションと `charsetSentinel` オプションの両方を指定すると、実際の文字セットを推定できる `utf8` パラメーターが要求に含まれている場合、`charset` はオーバーライドされます。 その意味では、`charset` は、権限のある文字セットではなく、既定の文字セットとして動作します。

```javascript
var detectedAsUtf8 = qs.parse('utf8=%E2%9C%93&a=%C3%B8', {
    charset: 'iso-8859-1',
    charsetSentinel: true
});
assert.deepEqual(detectedAsUtf8, { a: 'ø' });

// Browsers encode the checkmark as &#10003; when submitting as iso-8859-1:
var detectedAsIso8859_1 = qs.parse('utf8=%26%2310003%3B&a=%F8', {
    charset: 'utf-8',
    charsetSentinel: true
});
assert.deepEqual(detectedAsIso8859_1, { a: 'ø' });
```

`&#...;` 構文を実際の文字にデコードする場合は、`interpretNumericEntities` オプションも指定できます。

```javascript
var detectedAsIso8859_1 = qs.parse('a=%26%239786%3B', {
    charset: 'iso-8859-1',
    interpretNumericEntities: true
});
assert.deepEqual(detectedAsIso8859_1, { a: '☺' });
```

これは、`charsetSentinel` モードで文字セットが検出された場合にも機能します。

### <a name="parsing-arrays"></a>配列の解析

**qs** では、同様の `[]` 表記を使用して配列を解析することもできます。

```javascript
var withArray = qs.parse('a[]=b&a[]=c');
assert.deepEqual(withArray, { a: ['b', 'c'] });
```

インデックスも指定できます。

```javascript
var withIndexes = qs.parse('a[1]=c&a[0]=b');
assert.deepEqual(withIndexes, { a: ['b', 'c'] });
```

配列内のインデックスとオブジェクト内のキーの唯一の違いは、配列を作成するには角かっこの間の値が数値である必要があることに注意してください。 特定のインデックスを使用して配列を作成すると、**qs** では、順序を維持したまま、スパース配列を既存の値のみに圧縮します。

```javascript
var noSparse = qs.parse('a[1]=b&a[15]=c');
assert.deepEqual(noSparse, { a: ['b', 'c'] });
```

スパース配列の解析には、`allowSparse` オプションを使用することもできます。

```javascript
var sparseArray = qs.parse('a[1]=2&a[3]=5', { allowSparse: true });
assert.deepEqual(sparseArray, { a: [, '2', , '5'] });
```

空の文字列も値であり、保持されることに注意してください。

```javascript
var withEmptyString = qs.parse('a[]=&a[]=b');
assert.deepEqual(withEmptyString, { a: ['', 'b'] });

var withIndexedEmptyString = qs.parse('a[0]=b&a[1]=&a[2]=c');
assert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });
```

**qs** では、配列内のインデックスの指定も最大インデックスを `20` に制限します。 `20` より大きいインデックスを含む配列メンバーは、代わりに、インデックスをキーとして含むオブジェクトに変換されます。 これは、たとえば、だれかが `a[999999999]` を送信した場合に対処するために必要です。この非常に大きな配列を反復するにはかなりの時間がかかります。

```javascript
var withMaxIndex = qs.parse('a[100]=b');
assert.deepEqual(withMaxIndex, { a: { '100': 'b' } });
```

この制限は、`arrayLimit` オプションを渡すことによってオーバーライドすることができます。

```javascript
var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });
assert.deepEqual(withArrayLimit, { a: { '1': 'b' } });
```

配列の解析を完全に無効にするには、`parseArrays` を `false` に設定します。

```javascript
var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });
assert.deepEqual(noParsingArrays, { a: { '0': 'b' } });
```

表記を組み合わせた場合、**qs** は、2 つの項目を 1 つのオブジェクトにマージします。

```javascript
var mixedNotation = qs.parse('a[0]=b&a[b]=c');
assert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });
```

オブジェクトの配列を作成することもできます。

```javascript
var arraysOfObjects = qs.parse('a[][b]=c');
assert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });
```

コンマを使用して配列を結合すると、**qs** ではそれを解析できます
```javascript
var arraysOfObjects = qs.parse('a=b,c', { comma: true })
assert.deepEqual(arraysOfObjects, { a: ['b', 'c'] })
```
("_これは、`a={b:1},{c:d}`のような入れ子になったオブジェクトを変換することはできません_")。

### <a name="stringifying"></a>文字列化

[](#preventEval)
```javascript
qs.stringify(object, [options]);
```

文字列化した場合、**qs** では、既定により、出力が URI でエンコードされます。 オブジェクトは想定どおりに文字列化されます。

```javascript
assert.equal(qs.stringify({ a: 'b' }), 'a=b');
assert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');
```

このエンコードは、`encode` オプションを `false` に設定することにより無効にすることができます。

```javascript
var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });
assert.equal(unencoded, 'a[b]=c');
```

`encodeValuesOnly` オプションを `true` に設定すると、キーに対してエンコードを無効にすることができます。
```javascript
var encodedValues = qs.stringify(
    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
    { encodeValuesOnly: true }
);
assert.equal(encodedValues,'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h');
```

このエンコードは、`encoder` オプションとして設定されたカスタム エンコード メソッドに置き換えることができます

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {
    // Passed in values `a`, `b`, `c`
    return // Return encoded string
}})
```

" _(注: `encode` が `false`の場合、`encoder` オプションは適用されません)_ "。

`encoder` と同様に、`parse`には、プロパティと値のデコードをオーバーライドするための `decoder` オプションがあります。

```javascript
var decoded = qs.parse('x=z', { decoder: function (str) {
    // Passed in values `x`, `z`
    return // Return decoded string
}})
```

エンコーダーに提供される型引数を使用すると、異なるロジックを使用してキーと値をエンコードできます。

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str, defaultEncoder, charset, type) {
    if (type === 'key') {
        return // Encoded key
    } else if (type === 'value') {
        return // Encoded value
    }
}})
```

型引数は、デコーダーにも提供されます。

```javascript
var decoded = qs.parse('x=z', { decoder: function (str, defaultDecoder, charset, type) {
    if (type === 'key') {
        return // Decoded key
    } else if (type === 'value') {
        return // Decoded value
    }
}})
```

これ以降の例では、わかりやすくするために、出力が URI でエンコードされていない場合と同様の例を示します。 このような場合に返される値は、実際に使用する際には、URI でエンコード "*される*" ことに注意してください。

配列を文字列化すると、既定では、明示的なインデックスが与えられます。

```javascript
qs.stringify({ a: ['b', 'c', 'd'] });
// 'a[0]=b&a[1]=c&a[2]=d'
```

これは、`indices` オプションを `false` に設定することにより、オーバーライドできます。

```javascript
qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });
// 'a=b&a=c&a=d'
```

`arrayFormat` オプションを使用して、出力配列の形式を指定できます。

```javascript
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })
// 'a[0]=b&a[1]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })
// 'a[]=b&a[]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })
// 'a=b&a=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'comma' })
// 'a=b,c'
```

オブジェクトを文字列化した場合、既定では、角かっこ表記が使用されます。

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } });
// 'a[b][c]=d&a[b][e]=f'
```

`allowDots` オプションを `true` に設定することにより、これをオーバーライドしてドット表記を使用することができます。

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });
// 'a.b.c=d&a.b.e=f'
```

空の文字列と null 値では値が省略されますが、等号 (=) はそのまま残ります。

```javascript
assert.equal(qs.stringify({ a: '' }), 'a=');
```

値のないキー (空のオブジェクトや配列など) は何も返しません。

```javascript
assert.equal(qs.stringify({ a: [] }), '');
assert.equal(qs.stringify({ a: {} }), '');
assert.equal(qs.stringify({ a: [{}] }), '');
assert.equal(qs.stringify({ a: { b: []} }), '');
assert.equal(qs.stringify({ a: { b: {}} }), '');
```

`undefined` に設定されたプロパティは、完全に省略されます。

```javascript
assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');
```

必要に応じて、クエリ文字列の前に疑問符を付けることができます。

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&c=d');
```

区切り記号も、文字列化でオーバーライドできます。

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');
```

`Date` オブジェクトのシリアル化をオーバーライドする場合、`serializeDate` オプションを指定できます。

```javascript
var date = new Date(7);
assert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));
assert.equal(
    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),
    'a=7'
);
```

`sort` オプションを使用して、パラメーター キーの順序を変更することができます。

```javascript
function alphabeticalSort(a, b) {
    return a.localeCompare(b);
}
assert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&b=f&z=y');
```

最後に、`filter` オプションを使用して、文字列化された出力に含めるキーを制限できます。
関数を渡した場合、関数は、置換値を取得するためにキーごとに呼び出されます。 それ以外の場合、配列を渡すと、配列は、文字列化用のプロパティと配列インデックスを選択するために使用されます。

```javascript
function filterFunc(prefix, value) {
    if (prefix == 'b') {
        // Return an `undefined` value to omit a property.
        return;
    }
    if (prefix == 'e[f]') {
        return value.getTime();
    }
    if (prefix == 'e[g][0]') {
        return value * 2;
    }
    return value;
}
qs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });
// 'a=b&c=d&e[f]=123&e[g][0]=4'
qs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });
// 'a=b&e=f'
qs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });
// 'a[0]=b&a[2]=d'
```

### <a name="handling-of-null-values"></a>`null` 値の処理

既定では、`null` 値は、空の文字列と同様に扱われます。

```javascript
var withNull = qs.stringify({ a: null, b: '' });
assert.equal(withNull, 'a=&b=');
```

解析では、等号を含むパラメーターと含まないパラメーターは区別されません。 両方とも空の文字列に変換されます。

```javascript
var equalsInsensitive = qs.parse('a&b=');
assert.deepEqual(equalsInsensitive, { a: '', b: '' });
```

`null` 値と空の文字列を区別するには、`strictNullHandling` フラグを使用します。 結果文字列では、`null` 値に `=` 符号は含まれません。

```javascript
var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });
assert.equal(strictNull, 'a&b=');
```

`=` のない値を解析して `null` に戻すには、`strictNullHandling` フラグを使用します。

```javascript
var parsedStrictNull = qs.parse('a&b=', { strictNullHandling: true });
assert.deepEqual(parsedStrictNull, { a: null, b: '' });
```

`null` 値を含むキーのレンダリングを完全にスキップするには、`skipNulls` フラグを使用します。

```javascript
var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });
assert.equal(nullsSkipped, 'a=b');
```

レガシ システムと通信している場合、`charset` オプションを使用して `iso-8859-1` に切り替えることができます。

```javascript
var iso = qs.stringify({ æ: 'æ' }, { charset: 'iso-8859-1' });
assert.equal(iso, '%E6=%E6');
```

`iso-8859-1` に存在しない文字は、ブラウザーで行われる方法と同様に、済値エンティティに変換されます。

```javascript
var numeric = qs.stringify({ a: '☺' }, { charset: 'iso-8859-1' });
assert.equal(numeric, 'a=%26%239786%3B');
```

`charsetSentinel` オプションを使用すると、Ruby on Rails などでフォームを送信するときに行われる方法と同様に、チェックマークの場合は適切なエンコードで `utf8=✓` パラメーターを含めることにより、文字をアナウンスできます。

```javascript
var sentinel = qs.stringify({ a: '☺' }, { charsetSentinel: true });
assert.equal(sentinel, 'utf8=%E2%9C%93&a=%E2%98%BA');

var isoSentinel = qs.stringify({ a: 'æ' }, { charsetSentinel: true, charset: 'iso-8859-1' });
assert.equal(isoSentinel, 'utf8=%26%2310003%3B&a=%E6');
```

### <a name="dealing-with-special-character-sets"></a>特殊文字セットの処理

既定では、文字のエンコードとデコードは `utf-8` で行われ、`iso-8859-1` のサポートも、`charset` パラメーターを介して組み込まれます。

クエリ文字列を別の文字セット (たとえば、[Shift JIS](https://en.wikipedia.org/wiki/Shift_JIS)) にエンコードする場合、[`qs-iconv`](https://github.com/martinheidegger/qs-iconv) ライブラリを使用できます。

```javascript
var encoder = require('qs-iconv/encoder')('shift_jis');
var shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });
assert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');
```

これは、クエリ文字列のデコードでも機能します。

```javascript
var decoder = require('qs-iconv/decoder')('shift_jis');
var obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });
assert.deepEqual(obj, { a: 'こんにちは！' });
```

### <a name="rfc-3986-and-rfc-1738-space-encoding"></a>RFC 3986 および RFC 1738 のスペースのエンコード

RFC3986 は既定のオプションとして使用され、' ' を *%20* にエンコードします。これには下位互換性があります。
同時に、出力は RFC1738 に従って文字列化され、' ' は '+' と等しくなります。

```
assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');
```

## <a name="security"></a>セキュリティ

潜在的なセキュリティの脆弱性を報告する場合は、[@ljharb](https://github.com/ljharb) にメールを送信するか、 https://tidelift.com/security を参照してください。

## <a name="qs-for-enterprise"></a>エンタープライズ向け qs

Tidelift サブスクリプションの一部として利用可能

qs および何千もの他のパッケージのメンテナーは、Tidelift と協力して、アプリケーションをビルドするために使用するオープンソースの依存関係に対する商用サポートとメンテナンスを提供しています。 使用する正確な依存関係のメンテナーに支払いを行いながら、時間の節約、リスクの軽減、コードの正常性の向上を実現できます。 [詳細情報。](https://tidelift.com/subscription/pkg/npm-qs?utm_source=npm-qs&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)

[1]: https://npmjs.org/package/qs
[2]: http://versionbadg.es/ljharb/qs.svg
[3]: https://api.travis-ci.org/ljharb/qs.svg
[4]: https://travis-ci.org/ljharb/qs
[5]: https://david-dm.org/ljharb/qs.svg
[6]: https://david-dm.org/ljharb/qs
[7]: https://david-dm.org/ljharb/qs/dev-status.svg
[8]: https://david-dm.org/ljharb/qs?type=dev
[9]: https://ci.testling.com/ljharb/qs.png
[10]: https://ci.testling.com/ljharb/qs
[11]: https://nodei.co/npm/qs.png?downloads=true&stars=true
[license-image]: http://img.shields.io/npm/l/qs.svg
[license-url]: LICENSE
[downloads-image]: http://img.shields.io/npm/dm/qs.svg
[downloads-url]: http://npm-stat.com/charts.html?package=qs
