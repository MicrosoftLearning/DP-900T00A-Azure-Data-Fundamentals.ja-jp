---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052339"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![ビルドの状況](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

**Node.js バッファー リスト コレクター、リーダー、ストリーミング機能。**

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

**bl** は、ノード バッファーのコレクション用のストレージ オブジェクトであり、それらをメインのバッファー読み取り可能 API で公開します。 また、双方向ストリームとして機能するため、それらを出力するストリームからバッファーを収集し、それらを使用するストリームにバッファーを出力できます。

元のバッファーはそのまま保持され、コピーは必要な場合にのみ行われます。 1 つの元のバッファーを使用する必要がある読み取りでは、そのバッファーの 1 つのスライス (元のバッファーと同じメモリを参照する) のみが返されます。 複数のバッファーにわたる読み取りの場合、必要に応じて連結が実行され、結果が透過的に返されます。

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

コンストラクターにコールバックを指定し、 **[concat-stream](https://github.com/maxogden/node-concat-stream)** と同様に使用します。

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

このような *コールバック* メソッドを使用する場合、結果の `data` パラメーターはリスト内のすべての `Buffer` オブジェクトの連結であることに注意してください。 この連結のオーバーヘッドを回避する必要がある場合 (極めてパフォーマンス重視の場合) は、*コールバック* メソッドを避け、その代わりに、標準の Stream と同様に `'end'` をリッスンします。

または、[ハイパークエスト](https://github.com/substack/hyperquest)を使用して URL をフェッチするには、次のようにします ([要求](http://github.com/mikeal/request)とプレーンな Node http でも使用できます)。

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

または、これを読み取り可能なストリームとして使用して、バッファーのリストを出力ソースに再構成します。

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>API

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferList([ Buffer | Buffer array | BufferList | BufferList array | String ])
コンストラクターに引数は _必須_ ではありませんが、1 つの `Buffer` オブジェクトまたは `Buffer` オブジェクトの配列を渡すことによってリストを初期化できます。

`new` は厳密には必須ではありません。新しいオブジェクトのインスタンスを作成しなかった場合は自動的に実行されるため、次のように新しいインスタンスを作成できます。

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
渡されたオブジェクトが `BufferList` であるかどうかを決定します。 渡されたオブジェクトが `BufferList` **または** `BufferListStream` のインスタンスである場合は `true`、それ以外の場合は `false` が返されます。

注意 この静的メソッドが追加される前にこのライブラリのバージョンによって作成された `BufferList` または `BufferListStream` インスタンスについては、`true` は返されません。

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
リストの長さをバイト単位で取得します。 これは、リストに含まれるすべてのバッファーの長さの合計から、最初の時点で一部消費済みのバッファーの初期オフセットを差し引いたものです。 リストから読み取ることができる合計バイト数を正確に表します。

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(Buffer | Buffer array | BufferList | BufferList array | String)
`append(buffer)` により、内部リストに追加のバッファーまたは BufferList を追加します。 チェーンできるように `this` が返されます。

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(index)
`get()` により、指定したインデックス位置のバイトが返されます。

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()` により、指定したインデックス位置のバイトが返されます。
`indexOf()` メソッドにより、BufferList で特定の要素が見つかる最初のインデックスが返されます。存在しない場合は -1 が返されます。

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()` により、指定した範囲内のバイトを含む新しい `Buffer` オブジェクトが返されます。 `start` と `end` は両方とも省略可能であり、既定ではそれぞれリストの先頭と末尾になります。

要求した範囲が 1 つの内部バッファーにおさまる場合は、そのバッファーの元のメモリ範囲を共有するそのバッファーのスライスが返されます。 範囲が複数のバッファーにまたがる場合は、uniform バッファーを取得するためにコピー操作が発生する可能性があります。

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()` により、指定した範囲内のバイトを含む新しい `BufferList` オブジェクトが返されます。 `start` と `end` は両方とも省略可能であり、既定ではそれぞれリストの先頭と末尾になります。

コピーは実行されません。 結果に含まれるすべてのバッファーは、元のリストとメモリを共有します。

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()` により、リストの内容を `dest` バッファーにコピーします。これは `destStart` から始まり、`srcStart` と `srcEnd` で指定した範囲内のバイトを含みます。 `destStart`、`start`、`end` は省略可能であり、既定ではそれぞれ、`dest` バッファーの先頭と、リストの先頭と末尾になります。

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()` により、リストの **簡易コピー** を実行します。 内部バッファーは同じままであるため、基になるバッファーを変更すると、元のバッファーと複製の両方に変更が反映されます。 このメソッドは、`consume()` または `pipe()` を呼び出しながら、元のリストを保持する場合に必要です。次に例を示します。

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(bytes)
`consume()` により、*リストの先頭* からバイトをシフトします。 使用されるバイト数は、内部バッファーのサイズと一致する必要はありません。初期オフセットがそれに応じて計算され、データの一貫したビューが提供されます。

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()` により、バッファーの文字列表現が返されます。 省略可能な `start` および `end` 引数は `slice()` に渡され、一方、`encoding` は結果のバッファーの `toString()` に渡されます。 詳細については、[Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end) に関するドキュメントを参照してください。

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE()、bl.readDoubleLE()、bl.readFloatBE()、bl.readFloatLE()、bl.readInt32BE()、bl.readInt32LE()、bl.readUInt32BE()、bl.readUInt32LE()、bl.readInt16BE()、bl.readInt16LE()、bl.readUInt16BE()、bl.readUInt16LE()、bl.readInt8()、bl.readUInt8()

`Buffer` インターフェイスの標準バイト読み取りメソッドすべてが実装され、内部バッファー境界を越えて透過的に動作します。

これらがどのように動作するかについては、<b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b> のドキュメントを参照してください。

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferListStream([ callback | Buffer | Buffer array | BufferList | BufferList array | String ])
**BufferListStream** は Node の **[二重ストリーム](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)** であるため、標準の Node ストリームと同様に読み取りおよび書き込みを行うことができます。 **BufferListStream** インスタンスへの、またはそのインスタンスからの `pipe()` を使用することもできます。

コンストラクターは省略可能なコールバックを受け取ります。指定した場合、コールバックは、`bl.end()` が呼び出されたときに (つまり、パイプストリームから)、エラー引数とそれに続く **bl** インスタンスへの参照を使用して呼び出されます。 これは、ストリームの内容全体を収集する便利な方法です。ストリームが *chunky* である場合 (ネットワーク ストリームなど) は、特にそうです。

通常、コンストラクターに引数は "必須" ではありませんが、1 つの `Buffer` オブジェクトまたは `Buffer` オブジェクトの配列を渡すことによってリストを初期化できます。

`new` は厳密には必須ではありません。新しいオブジェクトのインスタンスを作成しなかった場合は自動的に実行されるため、次のように新しいインスタンスを作成できます。

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

注意 下位互換性の理由から、`BufferListStream` は、`require('bl')` を使用する場合の **既定** のエクスポートです。

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>共同作成者

**bl** は、次のハッカーによって提供されています。

 * [Rod Vagg](https://github.com/rvagg)
 * [Matteo Collina](https://github.com/mcollina)
 * [Jarett Cruger](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>ライセンスと著作権

Copyright (c) 2013-2019 bl contributors (listed above).

bl は MIT ライセンスにより許諾されています。 MIT ライセンスで明示的に付与されていないすべての権限は留保されています。 詳細については、付属の LICENSE.md ファイルを参照してください。
