---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052432"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **ビルド** | **依存関係** |
|-----------|---------------|
| [![ビルドの状況](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![依存関係の状態](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


[JSON Web トークン](https://tools.ietf.org/html/rfc7519)の実装。

これは、`draft-ietf-oauth-json-web-token-08` に対して開発されました。 これは、[node-jws](https://github.com/brianloveswords/node-jws)を使用します

# <a name="install"></a>[インストール]

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>移行に関する注意事項

* [v7 から v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>使用

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [オプション, コールバック])

(非同期) コールバックが指定されている場合、コールバックは、`err` または JWT で呼び出されます。

(同期) JsonWebToken を文字列として返します

`payload` には、有効な JSON を表すオブジェクト リテラル、バッファー、または文字列を指定できます。 
> `exp` またはその他のクレームは、ペイロードがオブジェクト リテラルである場合にのみ設定されることに **"注意" _してください_**。 バッファーまたは文字列のペイロードは、JSON の有効性についてチェックされません。

> `payload` がバッファーまたは文字列ではない場合、`JSON.stringify` を使用して文字列に強制変換されます。

`secretOrPrivateKey` は、HMAC アルゴリズムのシークレット、または RSA および ECDSA のエンコードされた秘密キーのいずれかを含む文字列、バッファー、またはオブジェクトです。 パスフレーズを含む秘密キーの場合、([暗号化ドキュメント](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format)に基づいて) オブジェクト `{ key, passphrase }` を使用できます。この場合、必ず `algorithm` オプションを渡してください。

`options`:

* `algorithm` (既定値: `HS256`)
* `expiresIn`: 秒、または期間 [zeit/ms](https://github.com/zeit/ms) を記述する文字列で表されます。 
  > 例: `60`、`"2 days"`、`"10h"`、`"7d"`。 数値は、秒数として解釈されます。 文字列を使用する場合、必ず、時間の単位 (日数、時間など) を指定してください。指定しない場合は、ミリ秒の単位が既定で使用されます (`"120"` は `"120ms"` と等しくなります)。
* `notBefore`: 秒、または期間 [zeit/ms](https://github.com/zeit/ms) を記述する文字列で表されます。 
  > 例: `60`、`"2 days"`、`"10h"`、`"7d"`。 数値は、秒数として解釈されます。 文字列を使用する場合、必ず、時間の単位 (日数、時間など) を指定してください。指定しない場合は、ミリ秒の単位が既定で使用されます (`"120"` は `"120ms"` と等しくなります)。
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`: true の場合、sign 関数は、ペイロード オブジェクトを直接変更します。 これは、クレームが適用された後、トークンにエンコードされる前に、ペイロードへの未処理の参照が必要な場合に役立ちます。



> `expiresIn`、`notBefore`、`audience`、`subject`、`issuer` の既定値はありません。  これらのクレームは、それぞれ `exp`、`nbf`、`aud`、`sub`、`iss` を使用してペイロードに直接提供することもできますが、両方の場所に含めることは **_できません_**。

`exp`、`nbf`、`iat` は **NumericDate** であることを忘れないでください。関連する「[トークンの有効期限 (exp クレーム)](#token-expiration-exp-claim)」を参照してください


ヘッダーは、`options.header` オブジェクトを使用してカスタマイズできます。

`noTimestamp` が指定されている場合を除いて、生成された jwts には、既定で `iat` (発行時) クレームが含まれます。 `iat` がペイロードに挿入されている場合、`options.expiresIn`で期間が指定された `exp` などの他の時間を計算するために、実際のタイムスタンプの代わりに使用されます。

既定値 (HMAC SHA256) を使用した同期署名

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

RSA SHA256 を使用した同期署名
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

非同期に署名
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

jwt を 30 秒さかのぼる
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>トークンの有効期限 (exp クレーム)

JWT の標準では、有効期限を表す `exp` が定義されています。 有効期限は、**NumericDate** として表されます。

> 1970-01-01T00:00:00Z UTC から指定された UTC 日時までの秒数を表す JSON 数値。うるう秒は無視されます。  これは、整数以外の値を表すことができる以外は、IEEE Std 1003.1, 2013 Edition [POSIX.1] の定義 "Seconds Since the Epoch" (エポックからの経過秒数) と同じです。この定義では、1 日が 86,400 秒ちょうどで計算されます。  一般的および UTC 固有の日付と時刻に関する詳細については、RFC3339 [RFC3339] を参照してください。

これは、`exp` フィールドには、エポックからの秒数を含める必要があることを意味します。

有効期限が 1 時間のトークンに署名する:

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

このライブラリでこのようなトークンを生成するもう 1 つの方法は、次のとおりです。

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [オプション, コールバック])

(非同期) コールバックが指定されている場合、関数は非同期的に動作します。 署名が有効で、オプションの有効期限、受信者、または発行者が有効である場合、コールバックは、デコードされたペイロードで呼び出されます。 それ以外の場合、コールバックはエラーで呼び出されます。

(同期) コールバックが指定されていない場合、関数は同期して動作します。 署名が有効で、オプションの有効期限、受信者、または発行者が有効である場合、デコードされたペイロードを返します。 それ以外の場合、エラーがスローされます。

`token` は、JsonWebToken 文字列です

`secretOrPublicKey` は、HMAC アルゴリズムのシークレット、または RSA および ECDSA の PEM でエンコードされた公開キーのいずれかを含む文字列またはバッファーです。
`jwt.verify` が非同期的に呼び出される場合、`secretOrPublicKey` を、シークレットまたは公開キーをフェッチする必要がある関数にすることができます。 詳細な例については、以下を参照してください

[こちらのコメント](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138) で言及しているとおり、base64 でエンコードされたシークレット (base64 を使用してエンコードされたランダム バイト) を想定しているライブラリは他にもあります。その場合は、`Buffer.from(secret, 'base64')` を渡すことができます。これにより、シークレットは base64 を使用してデコードされ、トークンの検証では元のランダム バイトが使用されます。

`options`

* `algorithms`: 許可されるアルゴリズムの名前を含む文字列のリスト。 たとえば、`["HS256", "HS384"]` です。
* `audience`: 受信者 (`aud`) を確認する場合は、値をここに指定します。 受信者は、文字列、正規表現、または文字列や正規表現のリストに対して確認することができます。 
  > 例: `"urn:foo"`、`/urn:f[o]{2}/`、`[/urn:f[o]{2}/, "urn:bar"]`
* `complete`: ペイロードの通常のコンテンツだけではなく、デコードされた `{ payload, header, signature }` を含むオブジェクトを返します。
* `issuer` (省略可能): `iss` フィールドの有効な値の文字列または文字列の配列。
* `ignoreExpiration`: `true` の場合、トークンの有効期限を検証しません。
* `ignoreNotBefore`...
* `subject`: 件名 (`sub`) を確認する場合、値をここに指定します
* `clockTolerance`: 異なるサーバー間でのクロックの微小な差に対処するために、`nbf` および `exp` クレームを確認するときに許容される秒数
* `maxAge`: トークンが引き続き有効になる最大許容期間。 これは、秒、または期間 [zeit/ms](https://github.com/zeit/ms) を記述する文字列で表されます。 
  > 例: `1000`、`"2 days"`、`"10h"`、`"7d"`。 数値は、秒数として解釈されます。 文字列を使用する場合、必ず、時間の単位 (日数、時間など) を指定してください。指定しない場合は、ミリ秒の単位が既定で使用されます (`"120"` は `"120ms"` と等しくなります)。
* `clockTimestamp`: 必要なすべての比較で現在の時刻として使用する必要がある時間 (秒)。
* `nonce`: `nonce` クレームを確認する場合は、文字列値をここに指定します。 これは、ID トークンの Open ID で使用されます ([Open ID の実装に関するメモ](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes))


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, オプション])

(同期) 署名が有効であるかどうかを検証せずに、デコードされたペイロードを返します。

> __警告:__ これは、署名が有効かどうかを検証 __しません__。 信頼されていないメッセージには、これを使用 __しない__ でください。 代わりに、`jwt.verify` を使用することになるでしょう。

`token` は、JsonWebToken 文字列です

`options`:

* `json`: ヘッダーに `"typ":"JWT"` が含まれていない場合でも、ペイロードに対して JSON.parse を強制します。
* `complete`: デコードされたペイロードとヘッダーを含むオブジェクトを返します。

例

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>エラーとコード
検証中にエラーがスローされる可能性があります。
エラーは、検証コールバックの最初の引数です。

### <a name="tokenexpirederror"></a>TokenExpiredError

トークンの有効期限が切れている場合、エラーがスローされます。

エラー オブジェクト:

* name:'TokenExpiredError'
* message: 'jwt の有効期限が切れています'
* expiredAt: [ExpDate]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
エラー オブジェクト:

* name:'JsonWebTokenError'
* メッセージ:
  * 'jwt の形式に誤りがあります'
  * 'jwt 署名が必要です'
  * '署名が無効です'
  * 'jwt 受信者が無効です。 期待値: [オプション 受信者]'
  * 'jwt 発行者が無効です。 期待値: [オプション 発行者]'
  * 'jwt ID が無効です。 期待値: [オプション JWT ID]'
  * 'jwt 件名が無効です。 期待値: [オプション 件名]'

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
現在の時刻が nbf クレームより前である場合、スローされます。

エラー オブジェクト:

* name:'NotBeforeError'
* message: 'jwt がアクティブではありません'
* date:2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>サポートされているアルゴリズム

サポートされているアルゴリズムの配列。 現在、次のアルゴリズムがサポートされています。

アルゴリズム パラメーター値 | デジタル署名または MAC アルゴリズム
----------------|----------------------------
HS256 | SHA-256 ハッシュ アルゴリズムを使用する HMAC
HS384 | SHA-384 ハッシュ アルゴリズムを使用する HMAC
HS512 | SHA-512 ハッシュ アルゴリズムを使用する HMAC
RS256 | SHA-256 ハッシュ アルゴリズムを使用する RSASSA-PKCS1-v1_5
RS384 | SHA-384 ハッシュ アルゴリズムを使用する RSASSA-PKCS1-v1_5
RS512 | SHA-512 ハッシュ アルゴリズムを使用する RSASSA-PKCS1-v1_5
PS256 | SHA-256 ハッシュ アルゴリズムを使用する RSASSA-PSS (ノード ^6.12.0 または >=8.0.0 のみ)
PS384 | SHA-384 ハッシュ アルゴリズムを使用する RSASSA-PSS (ノード ^6.12.0 または >=8.0.0 のみ)
PS512 | SHA-512 ハッシュ アルゴリズムを使用する RSASSA-PSS (ノード ^6.12.0 または >=8.0.0 のみ)
ES256 | P-256 曲線と SHA-256 ハッシュ アルゴリズムを使用する ECDSA
ES384 | P-384 曲線と SHA-384 ハッシュ アルゴリズムを使用する ECDSA
ES512 | P-521 曲線と SHA-512 ハッシュ アルゴリズムを使用する ECDSA
なし | デジタル署名または MAC 値は含まれません

## <a name="refreshing-jwts"></a>JWT の更新

まず、JWT の自動更新によってシステムに脆弱性が発生しないかどうかを慎重に検討することをお勧めします。

これをライブラリの一部として含めることに慣れていませんが、これをどのように実現できるかを示す[こちらの例](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48)を調べることができます。
その例とは別に、このトピックに関する知識を深めるための [イシュー](https://github.com/auth0/node-jsonwebtoken/issues/122) と [pull request](https://github.com/auth0/node-jsonwebtoken/pull/172) があります。

# <a name="todo"></a>TODO

* X.509 クライアント証明書チェーンは確認されていません

## <a name="issue-reporting"></a> 問題点の報告 

バグが見つかった場合、または機能要求がある場合、このリポジトリの Issue セクションで報告してください。 パブリックの GitHub イシュー トラッカーでセキュリティの脆弱性を報告しないでください。 セキュリティ上の問題を開示する手順については、「[責任ある開示プログラム](https://auth0.com/whitehat)」で詳細に説明しています。

## <a name="author"></a>Author

[Auth0](https://auth0.com)

## <a name="license"></a>ライセンス

このプロジェクトは、MIT ライセンスに基づいて使用が許諾されています。 詳細については、[LICENSE](LICENSE) ファイルを参照してください。
