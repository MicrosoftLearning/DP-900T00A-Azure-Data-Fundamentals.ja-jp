---
ms.openlocfilehash: 6e78f9de8f21b6501e007e86f631942016f041dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052216"
---
# <a name="jsbi--pure-javascript-bigints-build-statushttpstravis-cicomgooglechromelabsjsbi-jsbi-on-npmhttpswwwnpmjscompackagejsbi"></a>JSBI — pure-JavaScript BigInts [![ビルドの状態](https://travis-ci.com/GoogleChromeLabs/jsbi.svg?branch=main)](https://travis-ci.com/GoogleChromeLabs/jsbi) [![npm 上の jsbi](https://img.shields.io/npm/v/jsbi)](https://www.npmjs.com/package/jsbi)

JSBI は、ES2020 で JavaScript 言語の一部となった [ECMAScript BigInt 提案](https://tc39.es/proposal-bigint/)の純粋な JavaScript 実装です。

## <a name="installation"></a>インストール

```sh
npm install jsbi --save
```

## <a name="usage"></a>使用

```js
import JSBI from './jsbi.mjs';

const max = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
console.log(String(max));
// → '9007199254740991'
const other = JSBI.BigInt('2');
const result = JSBI.add(max, other);
console.log(String(result));
// → '9007199254740993'
```

注: `console.log()` を使用するときに任意の `JSBI` インスタンスに対して `toString` を明示的に呼び出して、その数値表現 (例: `String(max)` または `max.toString()`) を表示します。 それなしの場合 (例: `console.log(max)`)、代わりに値を表すオブジェクトが表示されます。

[babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) を使用して、JSBI コードをネイティブの BigInt コードにトランスパイルします。

詳細については、以下の詳細な手順を参照してください。

## <a name="why"></a>なぜですか?

[Native BigInts は、既に](https://v8.dev/features/bigint)最新のブラウザー (この記事の執筆時点で、Google Chrome 67+、Opera 54+、Firefox 68 以降) と Node.js (v10.4 以降) で出荷されており、今後他のブラウザーにも広げる予定です。つまり、コードをどこからでも実行したい場合は、まだ使用できません。

現在のコードで BigInts を使用するには、ライブラリが必要です。 しかし、問題があります。BigInt 提案では、BigInts で動作するように演算子 (`+`、`>=` など) の動作を変更しています。 これらの変更を直接ポリフィルすることは不可能です。また、Babel や同様のツールを使用して BigInt コードをフォールバック コードにトランスパイルすることは (ほとんどの場合) 不可能です。 その理由は、このようなトランスパイルでは、プログラム内のすべての単一の演算子を、その入力に対して型チェックを実行する関数の呼び出しに置き換える必要があり、許容できないパフォーマンスの低下が発生するためです。

その解決策は、ライブラリの構文を使用してコードを記述し、使用可能な場合は[ネイティブの BigInt コードにトランスパイルする](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint)方法です。 JSBI はまさにこの目的のために設計されています。今後のネイティブ BigInt とまったく同じように動作する BigInt "polyfill" 実装を提供しますが、現在のすべてのブラウザーに配布できる構文を備えています。

既存の他の BigInteger ライブラリを上回る利点は次のとおりです。

- これは、ネイティブの BigInts が使用可能になったときとまったく同じように動作するため、それらに移行するには、コードの構文を[機械的に](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint)更新できます。そのロジックを再考する必要はありません。
- パフォーマンスに重点を置いています。 平均して、JSBI は Google Chrome が現在出荷しているネイティブ実装とパフォーマンスにおいて競争力があります。

## <a name="how"></a>方法はありますか。

構文の機械的な違いを除いて、[ネイティブの BigInts を使用するのと同様に、](https://developers.google.com/web/updates/2018/05/bigint)JSBI-BigInts を使用します。 `BigInt` を `JSBI.BigInt` に置き換えた後でも、同じように見えるものがあります。

| 操作            | ネイティブ BigInts          | JSBI                     |
| -------------------- | ----------------------- | ------------------------ |
| 文字列からの作成 | `a = BigInt('456')`     | `a = JSBI.BigInt('456')` |
| 数値からの作成 | `a = BigInt(789)`       | `a = JSBI.BigInt(789)`   |
| 文字列への変換 | `a.toString(radix)`     | `a.toString(radix)`      |
| 数値への変換 | `Number(a)`             | `JSBI.toNumber(a)`       |
| 切り捨て           | `BigInt.asIntN(64, a)`  | `JSBI.asIntN(64, a)`     |
|                      | `BigInt.asUintN(64, a)` | `JSBI.asUintN(64, a)`    |
| 型チェック           | `typeof a === 'bigint'` | `a instanceof JSBI`      |

ほとんどの演算子はメソッド呼び出しに置き換えられます。

| 操作                   | ネイティブ BigInts | JSBI                              |
| --------------------------- | -------------- | --------------------------------- |
| 加算                    | `c = a + b`    | `c = JSBI.add(a, b)`              |
| 減算                 | `c = a - b`    | `c = JSBI.subtract(a, b)`         |
| 乗算              | `c = a * b`    | `c = JSBI.multiply(a, b)`         |
| 除算                    | `c = a / b`    | `c = JSBI.divide(a, b)`           |
| 剰余                   | `c = a % b`    | `c = JSBI.remainder(a, b)`        |
| 累乗              | `c = a ** b`   | `c = JSBI.exponentiate(a, b)`     |
| 否定                    | `b = -a`       | `b = JSBI.unaryMinus(a)`          |
| ビットごとの否定。            | `b = ~a`       | `b = JSBI.bitwiseNot(a)`          |
| 左シフト               | `c = a << b`   | `c = JSBI.leftShift(a, b)`        |
| 右シフト              | `c = a >> b`   | `c = JSBI.signedRightShift(a, b)` |
| ビット演算 “and”               | `c = a & b`    | `c = JSBI.bitwiseAnd(a, b)`       |
| ビット演算 “or”                | `c = a \| b`   | `c = JSBI.bitwiseOr(a, b)`        |
| ビット演算 “xor”               | `c = a ^ b`    | `c = JSBI.bitwiseXor(a, b)`       |
| 他の BigInts との比較 | `a === b`      | `JSBI.equal(a, b)`                |
|                             | `a !== b`      | `JSBI.notEqual(a, b)`             |
|                             | `a < b`        | `JSBI.lessThan(a, b)`             |
|                             | `a <= b`       | `JSBI.lessThanOrEqual(a, b)`      |
|                             | `a > b`        | `JSBI.greaterThan(a, b)`          |
|                             | `a >= b`       | `JSBI.greaterThanOrEqual(a, b)`   |

上記の関数は BigInts でのみ動作します。 (現在の実装では型チェックは実行されません。このようなチェックは、ユーザーが自分が行っている動作を把握しているという前提では時間の無駄になるためです。 他の入力で呼び出そうとしないでください。そうしない場合、"興味深い" エラーが発生します)

一部の操作は、BigInt と数値の比較や文字列と BigInt の連結など、混合型の入力を指定する場合に特に興味深いものです。 これらは、それぞれのネイティブ演算子にちなんだ静的関数として実装されます。

| 操作                       | ネイティブ BigInts | JSBI             |
| ------------------------------- | -------------- | ---------------- |
| 抽象等値比較    | `x == y`       | `JSBI.EQ(x, y)`  |
| ジェネリック型の "not equal"             | `x != y`       | `JSBI.NE(x, y)`  |
| ジェネリック型の "less than"             | `x < y`        | `JSBI.LT(x, y)`  |
| ジェネリック型の “less than or equal”    | `x <= y`       | `JSBI.LE(x, y)`  |
| ジェネリック型の “greater than”          | `x > y`        | `JSBI.GT(x, y)`  |
| ジェネリック型の “greater than or equal” | `x >= y`       | `JSBI.GE(x, y)`  |
| ジェネリック型の追加                | `x + y`        | `JSBI.ADD(x, y)` |

こちらの変数名 `x` と `y` は、変数が任意の値を参照できることを示しています。例: `JSBI.GT(101.5, BigInt('100'))` または `str = JSBI.ADD('result: ', BigInt('0x2A'))`。

残念ながら、サポートされていないものがいくつかあります。

| サポートされない操作 | ネイティブ BigInts | JSBI                                 |
| --------------------- | -------------- | ------------------------------------ |
| リテラル              | `a = 123n;`    | N/A ☹                                |
| increment             | `a++`          | N/A ☹                                |
|                       | `a + 1n`       | `JSBI.add(a, JSBI.BigInt('1'))`      |
| デクリメント             | `a--`          | N/A ☹                                |
|                       | `a - 1n`       | `JSBI.subtract(a, JSBI.BigInt('1'))` |

ネイティブ `++` と `--` 演算子の正確な動作を静的関数でレプリケートすることはできません。 JSBI は最終的にトランスパイルされることを意図しているため、同様の異なる代替手段を提供しません。 代わりに `JSBI.add()` および `JSBI.subtract()` 型を使用できます。

## <a name="when"></a>いつですか?

今すぐ! JSBI ライブラリは、今日中に使用できます。

BigInts があらゆる場所でネイティブにサポートされたら、[babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) を使用して、JSBI コードをネイティブの BigInt コードに一度だけトランスパイルします。

JSBI の今後の計画の詳細については、[issue トラッカー](https://github.com/GoogleChromeLabs/jsbi/issues)をご覧ください。

今後の計画の概要は、追加の BigInt 関連機能のステージング グラウンドとして JSBI ライブラリ (またはそれに対する拡張機能) を使用することです。 正式な提案は意図的に最小限に留めており、フォローアップ提案のためにさらなる “ライブラリ機能“ を残しています。 例として、結合 `exp`+`mod` 関数とビット操作関数があります。

## <a name="development"></a>開発

1. このリポジトリをクローンしてローカル ディレクトリに `cd` します。

1. `.nvmrc` で指定した Node.js バージョンを使用します。

     ```sh
     nvm use
     ```

1. 開発の依存関係をインストールします。

    ```sh
    npm install
    ```

1. テストを実行します。

    ```sh
    npm test
    ```

    コマンド一覧については、`npm run` を参照してください。

## <a name="for-maintainers"></a>保守担当者の場合

### <a name="how-to-publish-a-new-release"></a>新しいリリースを公開する方法

1. `main` ブランチで、`package.json` のバージョン番号を更新します。

    ```sh
    npm version patch -m 'Release v%s'
    ```

    `patch` の代わりに、[必要に応じて](https://semver.org/)`minor` または `major` を使用します。

    これにより、Git コミットとタグが生成されることに注意してください。

1. リリースのコミットとタグをプッシュします。

    ```sh
    git push
    ```

    その後、CI によって新しいリリースが npm に自動的に公開されます。
