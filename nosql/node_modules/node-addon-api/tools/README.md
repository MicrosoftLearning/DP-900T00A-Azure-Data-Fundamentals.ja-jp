---
ms.openlocfilehash: 3decbdeed6f0c742925a5be9b78f5251a4c0b569
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052160"
---
# <a name="tools"></a>ツール

## <a name="clang-format"></a>clang-format

clang-format チェック ツールは、変更されたコード行を指定された git-refs と比較してチェックするように設計されています。

## <a name="migration-script"></a>移行スクリプト

移行ツールは、移行プロセスでの反復作業を減らすように設計されています。 ただし、スクリプトは、すべてのものを自動的に変換することは意図されていません。 通常、いくつかの小さな修正と大規模な再構築が必要です。

### <a name="how-to-use"></a>使用方法

変換スクリプトを実行するには、最初に、`node_modules` ディレクトリに最新の `node-addon-api` があることを確認します。
```
npm install node-addon-api
```

次に、プロジェクト ディレクトリを渡すスクリプトを実行します
```
node ./node_modules/node-addon-api/tools/conversion.js ./
```

終了したら、スクリプトで見逃されたものを再コンパイルしてデバッグします。


### <a name="quick-fixes"></a>簡単な修正
簡単に修正できるものの一覧を次に示します。
  1. JavaScript に値を返さないメソッドの戻り値を、void に変更します。
  2. Napi::Object で属性にアクセスしたり、メンバー関数を呼び出したりするには、`->` ではなく `.` を使います。
  3. `Napi::New(env, value);` を `Napi::[Type]::New(env, value); にします


### <a name="major-reconstructions"></a>主な再構築
`Napi::ObjectWrap` の実装は、NAN のものと大きく異なります。 `Napi::ObjectWrap` は、ラップされたオブジェクトへのポインターを受け取り、ObjectWrap コンストラクター内のラップされたオブジェクトへの参照を作成します。 また、`Napi::ObjectWrap` は、ラップされたオブジェクトのインスタンス メソッドを、NAN のような静的メソッドではなく、Javascript モジュールに関連付けます。

そのため、モジュールで Nan::ObjectWrap を使用する場合は、次の手順を実行する必要があります。

  1. [ClassName]::New 関数を、`Napi::CallbackInfo` を受け取るコンストラクター関数に変換します。 それを次のように宣言します
```
[ClassName](const Napi::CallbackInfo& info);
```
そして、次のように定義します
```
[ClassName]::[ClassName](const Napi::CallbackInfo& info) : Napi::ObjectWrap<[ClassName]>(info){
  ...
}
```
これにより、`Napi::ObjectWrap` コンストラクターはオブジェクトがインスタンス化された後で呼び出され、`Napi::ObjectWrap` は `this` ポインターを使ってラップされたオブジェクトへの参照を作成できます。

  2. 元のコンストラクター コードを、新しいコンストラクターに移動します。 元のコンストラクターを削除します。
  3. クラス初期化関数で、次のようにネイティブ メソッドを関連付けます。
```
Napi::FunctionReference constructor;

void [ClassName]::Init(Napi::Env env, Napi::Object exports, Napi::Object module) {
  Napi::HandleScope scope(env);
  Napi::Function ctor = DefineClass(env, "Canvas", {
    InstanceMethod<&[ClassName]::Func1>("Func1"),
    InstanceMethod<&[ClassName]::Func2>("Func2"),
    InstanceAccessor<&[ClassName]::ValueGetter>("Value"),
    StaticMethod<&[ClassName]::StaticMethod>("MethodName"),
    InstanceValue("Value", Napi::[Type]::New(env, value)),
  });

  constructor = Napi::Persistent(ctor);
  constructor .SuppressDestruct();
  exports.Set("[ClassName]", ctor);
}
```
  4. `[ClassName]* native = Nan::ObjectWrap::Unwrap<[ClassName]>(info.This());` のように NAN 内の ObjectWrap をラップ解除する必要がある関数では、各 ObjectWrap インスタンスが一意のオブジェクト インスタンスに関連付けられているので、ラップされていないオブジェクトとして `this` ポインターを直接使用します。


このガイドに従った後も問題がある場合は、問題について説明した issue を残してください。こちらで解決を試みます。
