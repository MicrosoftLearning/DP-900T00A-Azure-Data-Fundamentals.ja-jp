---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/05/2022
ms.locfileid: "138053056"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![ダウンロード][downloads-image]][downloads-url] [![javascript スタイル ガイド][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>より安全な Node.js Buffer API

**すべてのバージョンの Node.js で、新しい Node.js Buffer API (`Buffer.from`、`Buffer.alloc`、`Buffer.allocUnsafe`、`Buffer.allocUnsafeSlow`) を使用してください。**

**使用可能な場合は、組み込みの実装を使用します。**

## <a name="install"></a>インストール

```
npm install safe-buffer
```

## <a name="usage"></a>usage

このパッケージの目的は、node.js `Buffer` の安全な置き換えを実現することです。

`Buffer` の代わりとして、そのまま使用できます。 node.js モジュールの先頭に `require` 行を 1 行追加します。

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>クラス メソッド: Buffer.from(array)
<!-- YAML
added: v3.0.0
-->

* `array` {Array}

オクテットの `array` を使用して新しい `Buffer` を割り当てます。

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

`array` が `Array` でない場合は、`TypeError` がスローされます。

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>クラス メソッド: Buffer.from(arrayBuffer[, byteOffset[, length]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} `TypedArray` または `new ArrayBuffer()` の `.buffer` プロパティ
* `byteOffset` {Number} 既定値: `0`
* `length` {Number} 既定値: `arrayBuffer.length - byteOffset`

`TypedArray` インスタンスの `.buffer` プロパティへの参照を渡すと、新しく作成された `Buffer` は、TypedArray に割り当てられたのと同じメモリを共有します。

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

省略可能な `byteOffset` および `length` 引数には、`Buffer` と共有される `arrayBuffer` 内のメモリ範囲を指定します。

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

`arrayBuffer` が `ArrayBuffer` でない場合、`TypeError` がスローされます。

### <a name="class-method-bufferfrombuffer"></a>クラス メソッド: Buffer.from(buffer)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

渡された `buffer` データを新しい `Buffer` インスタンスにコピーします。

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

`buffer` が `Buffer` でない場合、`TypeError` がスローされます。

### <a name="class-method-bufferfromstr-encoding"></a>クラス メソッド: Buffer.from(str[, encoding])
<!-- YAML
added: v5.10.0
-->

* `str` {String} エンコードする文字列。
* `encoding` {String} 使用するエンコード。既定値: `'utf8'`

指定した JavaScript 文字列 `str` を含む新しい `Buffer` を作成します。 `encoding` パラメーターを指定した場合、それによって文字エンコードが識別されます。
指定しない場合、`encoding` は既定で `'utf8'` になります。

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

`str` が文字列でない場合、`TypeError` がスローされます。

### <a name="class-method-bufferallocsize-fill-encoding"></a>クラス メソッド: Buffer.alloc(size[, fill[, encoding]])
<!-- YAML
added: v5.10.0
-->

* `size` {Number}
* `fill` {Value} 既定値: `undefined`
* `encoding` {String} 既定値: `utf8`

`size` バイトの新しい `Buffer` を割り当てます。 `fill` が `undefined` の場合、`Buffer` は *0 で埋められます*。

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`size` は `require('buffer').kMaxLength` に等しいかそれより小さい必要があります (64 ビット アーキテクチャの場合、`kMaxLength` は `(2^31)-1` です)。 そうでない場合は、`RangeError` がスローされます。 0 に等しいかそれより小さい `size` を指定すると、長さ 0 の Buffer が作成されます。

`fill` を指定した場合、割り当てられた `Buffer` は、`buf.fill(fill)` を呼び出すことによって初期化されます。 詳細については、「[`buf.fill()`][]」を参照してください。

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

`fill` と `encoding` を両方指定した場合、割り当てられた `Buffer` は、`buf.fill(fill, encoding)` を呼び出すことによって初期化されます。 次に例を示します。

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

`Buffer.alloc(size)` を呼び出すと、代替の `Buffer.allocUnsafe(size)` よりも大幅に遅くなる可能性がありますが、新しく作成された `Buffer` インスタンスの内容に *機密データが含まれない* ことが確実になります。

`size` が数値でない場合、`TypeError` がスローされます。

### <a name="class-method-bufferallocunsafesize"></a>クラス メソッド: Buffer.allocUnsafe(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

*0 で埋められていない* `size` バイトの新しい `Buffer` を割り当てます。  `size` は `require('buffer').kMaxLength` に等しいかそれより小さい必要があります (64 ビット アーキテクチャの場合、`kMaxLength` は `(2^31)-1` です)。 そうでない場合は、`RangeError` がスローされます。 0 に等しいかそれより小さい `size` を指定すると、長さ 0 の Buffer が作成されます。

この方法で作成された `Buffer` インスタンスの基になるメモリは、*初期化されません*。 新しく作成された `Buffer` の内容は不明であり、*機密データが含まれている可能性があります*。 このような `Buffer` インスタンスをゼロに初期化するには、[`buf.fill(0)`][] を使用します。

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`size` が数値でない場合、`TypeError` がスローされます。

`Buffer` モジュールにより、サイズが `Buffer.poolSize` の内部 `Buffer` インスタンスが事前に割り当てられることに注意してください。これは、`Buffer.allocUnsafe(size)` (および非推奨の `new Buffer(size)` コンストラクター) を使用して作成された新しい `Buffer` インスタンスを高速に割り当てるためのプールとして使用されます。ただし、それは `size` が `Buffer.poolSize >> 1` (`Buffer.poolSize` の切り捨て値を 2 で除算したもの) に等しいかそれより小さい場合に限ります。 `Buffer.poolSize` の既定値は `8192` ですが、変更できます。

この事前割り当てされた内部メモリ プールの使用は、`Buffer.alloc(size, fill)` と `Buffer.allocUnsafe(size).fill(fill)` の呼び出しの主な違いです。具体的には、`Buffer.alloc(size, fill)` で内部 Buffer プールは使用 *されません* が、`Buffer.allocUnsafe(size).fill(fill)` では、`size` が `Buffer.poolSize` の半分に等しいかそれより小さい場合に内部 Buffer プールが使用 *されます*。 違いはわずかですが、`Buffer.allocUnsafe(size)` によって提供される追加のパフォーマンスがアプリケーションに必要な場合は、重要になることがあります。

### <a name="class-method-bufferallocunsafeslowsize"></a>クラス メソッド: Buffer.allocUnsafeSlow(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

*0 で埋められておらず*、プールされない `size` バイトの新しい `Buffer` を割り当てます。  `size` は `require('buffer').kMaxLength` に等しいかそれより小さい必要があります (64 ビット アーキテクチャの場合、`kMaxLength` は `(2^31)-1` です)。 そうでない場合は、`RangeError` がスローされます。 0 に等しいかそれより小さい `size` を指定すると、長さ 0 の Buffer が作成されます。

この方法で作成された `Buffer` インスタンスの基になるメモリは、*初期化されません*。 新しく作成された `Buffer` の内容は不明であり、*機密データが含まれている可能性があります*。 このような `Buffer` インスタンスをゼロに初期化するには、[`buf.fill(0)`][] を使用します。

`Buffer.allocUnsafe()` を使用して新しい `Buffer` インスタンスを割り当てる場合、4KB 未満の割り当ては、既定では、1 個の事前割り当てされた `Buffer` からスライスされます。 これにより、アプリケーションは、個別に割り当てられた多数のバッファーを作成することによるガベージ コレクションのオーバーヘッドを回避できます。 この方法では、多くの `Persistent` オブジェクトを追跡してクリーンアップする必要がなくなり、パフォーマンスとメモリ使用量の両方が向上します。

ただし、開発者がプールからメモリの小さなチャンクを不確定な時間保持する必要がある場合は、`Buffer.allocUnsafeSlow()` を使用して、プールされていない Buffer インスタンスを作成してから、関連するビットをコピーすることが適切な場合があります。

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

`Buffer.allocUnsafeSlow()` を使用する場合、開発者がアプリケーションで過度のメモリ保有を確認した *後* の、最後の手段としてのみ使用する必要があります。

`size` が数値でない場合、`TypeError` がスローされます。

### <a name="all-the-rest"></a>残りのすべて

残りの `Buffer` API は、node.js とまったく同じです。
[ドキュメントを参照してください](https://nodejs.org/api/buffer.html)。


## <a name="related-links"></a>関連リンク

- [Node.js の issue: Buffer(number) は安全でない](https://github.com/nodejs/node/issues/4660)
- [Node.js 拡張提案: Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() のソフト非推奨](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>`Buffer` はなぜ安全でないのでしょうか?

現在、node.js の `Buffer` コンストラクターは、`String`、`Array`、`Object`、`TypedArrayView` (`Uint8Array` など)、`ArrayBuffer`、また `Number` のような多くの異なる引数の型を処理するようにオーバーロードされています。

API は利便性のために最適化されています。任意の型をスローすることができ、それにより必要な操作が実行されます。

Buffer コンストラクターは非常に強力であるため、次のようなコードを目にすることがよくあります。

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

***しかし、`Number` 引数で `toHex` が呼び出された場合はどうなるでしょうか?***

### <a name="remote-memory-disclosure"></a>リモート メモリ公開

攻撃者は、あなたのプログラムで `Number` 引数を持つ `Buffer` コンストラクターを呼び出すことができれば、node.js プロセスから初期化されていないメモリを割り当てることができます。
これにより、TLS 秘密キー、ユーザー データ、またはデータベース パスワードが漏えいする可能性があります。

`Buffer` コンストラクターに `Number` 引数が渡されると、指定された `size` の **UNINITIALIZED** メモリ ブロックが返されます。 このように `Buffer` を作成したときは、内容を上書きしてからユーザーに返す **必要があります**。

[node.js のドキュメント](https://nodejs.org/api/buffer.html#buffer_new_buffer_size)より:

> `new Buffer(size)`
>
> - `size` 数値
>
> この方法で作成された `Buffer` インスタンスの基になるメモリは初期化されません。
> **新しく作成された `Buffer` の内容は不明であり、機密データを含む可能性があります。** `buf.fill(0)` を使用してバッファーをゼロに初期化してください。

(自分たちのものを強調。)

初期化されていない `Buffer` を作成することをプログラマが意図したのであれば、多くの場合、次のようなコードになります。

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>これは実際のコードで問題になるでしょうか?

はい。 JavaScript のような動的に型指定される言語で変数の型を確認し忘れることは、驚くほどよくあります。

通常、間違った型が想定された場合、プログラムはキャッチされない例外によってクラッシュします。 ただし、`Buffer` コンストラクターの引数の型を確認し忘れることによるエラー モードの方が致命的です。

JSON ペイロードを受け取り、それを 16 進数に変換する脆弱なサービスの例を次に示します。

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

この例では、http クライアントは以下を送信するだけで済みます。

```json
{
  "str": 1000
}
```

すると、サーバーから 1,000 バイトの初期化されていないメモリが返されます。

これは非常に深刻なバグです。 その重大度は、リモート攻撃者による OpenSSL プロセス メモリの公開を可能にした [Heartbleed のバグ](http://heartbleed.com/)と同様です。


### <a name="which-real-world-packages-were-vulnerable"></a>脆弱な実際のパッケージはどれですか?

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

[Mathias Buus](https://github.com/mafintosh) と私 ([Feross Aboukhadijeh](http://feross.org/)) は、自分たちのパッケージの 1 つである [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht) で、この問題を見つけました。 このバグにより、インターネット上のあらゆるユーザーが一連のメッセージを `bittorrent-dht` のユーザーに送信し、node.js プロセスから初期化されていないメモリの時点で 20 バイトを明らかにできるようになります。

これを修正したコミットは[こちら](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8)です。 新しい修正バージョンがリリースされ、[Node Security Project の公開情報](https://nodesecurity.io/advisories/68)が作成されて、すべての脆弱なバージョンが npm で非推奨になりました。ユーザーは新しいバージョンにアップグレードするように警告を受け取ります。

#### [`ws`](https://www.npmjs.com/package/ws)

これに伴い、私たちは他の脆弱なパッケージの存在を懸念しました。 思ったとおり、短い間に、node.js で最もよく使用されている WebSocket 実装である [`ws`](https://www.npmjs.com/package/ws) に同じ問題が見つかりました。

特定の API が、想定される `String` または `Buffer` ではなく `Number` パラメーターを指定して呼び出された場合、初期化されていないサーバー メモリがリモート ピアに公開されていました。

これらは脆弱な方法でした。

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

何らかのエコー機能を備えた脆弱なソケット サーバーを次に示します。

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

`socket.send(number)` がサーバー上で呼び出されると、サーバー メモリが公開されます。

問題が修正されたリリースは[こちら](https://github.com/websockets/ws/releases/tag/1.0.1)です。より詳しい説明が記載されています。 迅速に修正してくれた [Arnout Kazemier](https://github.com/3rd-Eden) に敬意を表します。 [Node Security Project の公開情報はこちらです](https://nodesecurity.io/advisories/67)。


### <a name="whats-the-solution"></a>ソリューションはどのようなものか

node.js がメモリを迅速に取得する方法を提供することは重要です。そうでなければ、パフォーマンスが重要なアプリケーションが不必要に大幅に遅くなります。

しかし、プログラマとしての "*意図を示す*" ために、もっと良い方法が必要です。 **初期化されていないメモリが必要な場合は、明示的に要求する必要があります。**

さまざまな型をゆるやかに受け入れる、開発者にとって使いやすい API に、機密性の高い機能はパッケージされるべきではありません。 この種の API では、非常に慎重に型をチェックすることなく変数を渡すという、大まかな方法を実践しやすくなります。

#### <a name="a-new-api-bufferallocunsafenumber"></a>新しい API: `Buffer.allocUnsafe(number)`

初期化されていないメモリを使用してバッファーを作成する機能は、別の API の一部とする必要があります。 私たちは `Buffer.allocUnsafe(number)` を提案します。 このようにすれば、さまざまな種類のユーザー入力を頻繁に受け取る API の一部にはなりません。

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>コア node.js を修正する方法

1 つのケースに対する対策として [PR を node.js コアに](https://github.com/nodejs/node/pull/4514) (`semver-major` としてマージされている) 送信しました。

```js
var str = 16
new Buffer(str, 'utf8')
```

この状況では、プログラマが最初の引数を文字列として意図していたことが暗黙的に示されます。なぜなら、2 番目の引数としてエンコードを渡しているからです。 現在、node.js では、`new Buffer(number, encoding)` の場合は初期化されていないメモリが割り当てられますが、それはおそらくプログラマが意図したことではありません。

しかし、これは部分的な解決策にすぎません。なぜなら、プログラマが `new Buffer(variable)` を (`encoding` パラメーターなしで) 実行した場合、何を意図しているのかを知る方法がないからです。 `variable` が数値である場合があるのなら、場合によって初期化されていないメモリが返されます。

### <a name="whats-the-real-long-term-fix"></a>実際の長期的な修正は何か

`new Buffer(number)` を非推奨にして削除し、初期化されていないメモリが必要なときは `Buffer.allocUnsafe(number)` を使用できます。 しかし、そうすれば数千ものパッケージが機能しなくなるでしょう。

~~最善の解決策は次の方法だと私たちは考えます。~~

"~~1.安全な、0 で埋められたメモリを返すように `new Buffer(number)` を変更します~~

~~2. 初期化されていないバッファーを作成するための新しい API を作成します。私たちの提案: `Buffer.allocUnsafe(number)`~~

#### <a name="update"></a>更新

3 つの新しい API の追加がサポートされるようになりました。

- `Buffer.from(value)` - 任意の型をバッファーに変換する
- `Buffer.alloc(size)` - 0 で埋められたバッファーを作成する
- `Buffer.allocUnsafe(size)` - 指定したサイズの初期化されていないバッファーを作成する

これにより、`ws` と `bittorrent-dht` に影響していた、`Buffer(variable)` の数値引数の受け取りが悪用されるという主要な問題が解決されます。

これにより、既存のコードは引き続き機能し、npm エコシステムへの影響は最小限になります。 将来的に、npm 保守管理者はパフォーマンスが重要なコードを移行して、`new Buffer(number)` ではなく `Buffer.allocUnsafe(number)` を使用することができます。


### <a name="conclusion"></a>まとめ

現行の API に関して、`Buffer` に重大な設計上の問題があると私たちは考えます。 リスクの高い機能を、わかりやすい "開発者の人間工学" を備えた便利な API に組み込むことで、安全でないソフトウェアができやすくなります。

これは単なる理論的な課題ではありませんでした。最もよく使われている npm パッケージの一部で問題を見つけたからです。

さいわい、今すぐに適用できる簡単な修正があります。 `buffer` の代わりに `safe-buffer` を使用することです。

```js
var Buffer = require('safe-buffer').Buffer
```

最終的には、node.js コアがこの新しい、より安全な動作に切り替わることを願っています。 破壊的変更ではないため、エコシステムへの影響は最小限に抑えられると考えています。
管理の行き届いた、よく使用されているパッケージは、`Buffer.alloc` を使用するようにすぐに更新されますが、以前の安全でないパッケージでこの攻撃ベクトルの危険がなくなることは魔法のようなものです。


## <a name="links"></a>links

- [Node.js PR: buffer: length と enc が両方渡された場合はスロー](https://github.com/nodejs/node/pull/4514)
- [Node Security Project の `ws` に関する公開情報](https://nodesecurity.io/advisories/67)
- [Node Security Project の `bittorrent-dht` に関する公開情報](https://nodesecurity.io/advisories/68)


## <a name="credit"></a>クレジット

`bittorrent-dht` ([公開情報](https://nodesecurity.io/advisories/68)) および `ws` ([公開情報](https://nodesecurity.io/advisories/67)) における元の issue は、[Mathias Buus](https://github.com/mafintosh) と [Feross Aboukhadijeh](http://feross.org/) によって発見されました。

[Adam Baldwin](https://github.com/evilpacket) に感謝します。彼はこれらの issue を明らかにするのを助け、[Node Security Project](https://nodesecurity.io/) を運営する仕事をしてくれています。

この README を校正し、コードを監査してくれた [John Hiesey](https://github.com/jhiesey) に感謝します。


## <a name="license"></a>license

MIT. Copyright (C) [Feross Aboukhadijeh](http://feross.org)
