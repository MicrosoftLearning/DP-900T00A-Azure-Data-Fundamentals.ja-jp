---
ms.openlocfilehash: 606577c19ba4af45e2f7a9a083daf02adf0e2a70
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/05/2022
ms.locfileid: "145884725"
---
# <a name="table-of-contents"></a>目次

***
**[互換性](#compatibility)**

1. [MSAL.jsでサポートされているブラウザーは何ですか?](#what-browsers-are-supported-by-msaljs)
1. [ADAL.js から MSAL.js に移行しています。何を知っている必要がありますか?](#i-am-moving-from-adaljs-to-msaljs-what-should-i-know)
1. [MSAL-Angular 0.x から MSAL-Angular 1.x に移行しています。何を知っている必要がありますか?](#i-am-moving-from-msal-angular-0x-to-msal-angular-1x-what-should-i-know)

**[認証](#authentication)**

1. [リダイレクト フローのことを理解していません。handleRedirectCallback 関数はどのように機能しますか?](#i-dont-understand-the-redirect-flow-how-does-the-handleredirectcallback-function-work)
1. [個人の Microsoft アカウントのみで認証をサポートするにはどうすればよいですか?](#how-can-i-support-authentication-with-personal-microsoft-accounts-only)
1. [複数のユーザーをアプリケーションにログインさせるにはどうすればよいですか?](#how-do-i-log-in-multiple-users-to-my-application)

**[シングル サインオン](#single-sign-on)**

1. [MSAL.js を使用してアプリケーションにシングル サインオンするにはどうすればよいですか?](#how-to-get-single-sign-on-in-my-application-with-msaljs)
1. [サインイン後のユーザーをアプリケーションで認識するにはどうすればよいですか? アプリケーション間でユーザーを関連付けるにはどうすればよいですか?](#how-can-my-application-recognize-a-user-after-sign-in-how-do-i-correlate-users-between-applications)

**[構成](#configuration)**

1. [redirectUri として設定するものを決定するにはどうすればよいですか?](#how-do-i-decide-what-to-set-as-my-redirecturi)
1. [MSAL.js 認証要求でカスタム状態パラメーターの値を渡すにはどうすればよいですか?次に例を示します。ユーザーがいるページまたはカスタム情報を redirect_uri に渡すとき](#how-do-i-pass-custom-state-parameter-value-in-msaljs-authentication-request-for-example-when-you-want-to-pass-the-page-the-user-is-on-or-custom-info-to-your-redirect_uri)
1. [sessionStorage と localStorage の違いは何ですか?](#what-is-the-difference-between-sessionstorage-and-localstorage)
1. [authority 文字列は Azure AD ポータルのどこにありますか?](#where-is-the-authority-domain-string-on-azure-ad-portal)

**[トークン](#tokens)**

1. [MSAL.js でトークンを更新するにはどうすればよいですか?](#how-do-i-renew-tokens-with-msaljs)
1. [トークンをより速く取得するにはどうすればよいですか?](#how-can-i-acquire-tokens-faster)
1. [トークンはどれくらいの間存在していますか? その有効期間はどれくらいですか?](#how-long-do-tokens-last-how-long-are-they-valid-for)
1. [応答の accessToken フィールドが空になっているのはなぜですか?](#why-is-the-accessToken-field-in-the-response-empty)

**[スコープとリソース](#scopes--resources)**

1. [アプリケーションで複数のリソースにアクセスする必要があります。アクセス トークンのスコープをどのように処理する必要がありますか?](#my-application-has-multiple-resources-it-needs-to-access-to-how-should-i-handle-scopes-for-access-tokens)
1. [サンプルでは、スコープが loginRequest オブジェクトと tokenRequest オブジェクトに渡されています。ログインの間にスコープを渡すのと、トークンの取得の間にスコープを受すのでは、何が違いますか?](#in-the-samples-i-see-scopes-passed-in-loginrequest-and-tokenrequest-objects-what-is-the-difference-between-passing-scopes-during-login-vs-passing-scopes-during-token-acquisition)
1. [要求していないにもかかわらず、トークンにスコープ openid、profile、email、offline_access が含まれます。それらは何ですか?](#im-seeing-scopes-openid-profile-email-offline_access-and-userread-in-my-tokens-even-though-i-havent-requested-them-what-are-they)

**[テナントと対象ユーザー](#tenancy--audience)**

1. [アプリをマルチテナントにするには、何を行う必要がありますか?](#what-do-i-need-to-make-my-app-multi-tenant)
1. [Web API のようにユーザーの対話式操作機能を持たないアプリに管理者の同意を提供するにはどうすればよいですか?](#how-do-i-provide-admin-consent-for-an-app-that-has-no-user-interaction-capability-like-a-web-api)
1. [サポートされる対象ユーザーとアカウントの種類の違いは何ですか?](#what-are-the-differences-between-supported-audiences-and-account-types)

**[B2C](#b2c)**

1. [B2C アプリケーションに複数のユーザー フローとポリシーがあります。MSAL.js で複数のポリシーを使用するにはどうすればよいですか?](#my-b2c-application-has-more-than-one-user-flowpolicy-how-do-i-work-with-multiple-policies-in-msaljs)
1. [MSAL.js を使用して B2C アプリケーションにパスワード リセット ユーザー フローを実装するにはどうすればよいですか?](#how-can-i-implement-password-reset-user-flow-in-my-b2c-application-with-msaljs)
1. [アプリケーションからログアウトしました。ログインし直そうとしたときに資格情報の入力を求められないのはなぜですか?](#i-logged-out-of-my-application-why-am-i-not-asked-for-credentials-when-i-try-to-log-back-in)
1. [招待リンクから戻るときにサインインしていないのはなぜですか?](#why-am-i-not-signed-in-when-returning-from-an-invite-link)
1. [問題がライブラリではなく B2C サービス自体にあると思われる場合はどうすればよいですか?](#what-should-i-do-if-i-believe-my-issue-is-with-the-b2c-service-itself-rather-than-with-the-library)

**[一般的な問題](#common-issues)**
1. [トークンを自動的に取得して更新するときに、ページが再度読み込まれないようにするにはどうすればよいですか?](#how-to-avoid-page-reloads-when-acquiring-and-renewing-tokens-silently)
1. [アプリケーションが無限リダイレクト ループでスタックするのはなぜですか?](#why-is-my-application-stuck-in-an-infinite-redirect-loop)
1. [Internet Explorer でサンプルの 1 つを使用していると、SignIn() が定義されていないというエラーが発生します](#im-using-one-of-your-samples-on-internet-explorer-and-i-get-the-error-signin-is-not-defined)
1. [MSAL でエラーがスローされるのはなぜですか?](https://github.com/AzureAD/microsoft-authentication-library-for-js/tree/dev/lib/msal-core/docs/errors.md)

***

# <a name="compatibility"></a>互換性

## <a name="what-browsers-are-supported-by-msaljs"></a>MSAL.jsでサポートされているブラウザーは何ですか?

MSAL.js は、次のブラウザーでテストされています。

IE 11、Edge、Chrome、Firefox、Safari

[IE で MSAL.js を使用する](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/Using-msal.js-with-Internet-Explorer)ときは、次の手順に注意してください。

Safari、IE、Edge については、既知の問題と軽減策が文書化されています。 次のことを確認してください。
* [IE と Edge で既知の問題](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/Known-issues-on-IE-and-Edge-Browser)
* [Safari での既知の問題](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/Known-issue-on-Safari)

## <a name="i-am-moving-from-adaljs-to-msaljs-what-should-i-know"></a>ADAL.js から MSAL.js に移行しています。 何を知っている必要がありますか?

MSAL.js は Azure AD v2.0 エンドポイントと統合されますが、ADAL.js は Azure AD v1.0 エンドポイントと統合されます。 v1.0 エンドポイントでは、職場と学校アカウントはサポートされますが、個人アカウントはさぽーとされません。 v2.0 エンドポイントでは、職場、学校、個人の Microsoft アカウントが、1 つの認証システムに結合されています。 さらに、MSAL.js を使うと、Azure AD B2C の認証も実現できます。

**v1.0 と v2.0 エンドポイントでの認証の主な違い**

* **認証要求でのリソース パラメーターではなくスコープ**

    Azure AD v2.0 プロトコルでは、リソースではなくスコープが要求で使用されます。 つまり、アプリケーションが、MS Graph などのリソースのアクセス許可でトークンを要求する必要がある場合、ライブラリ メソッドに渡される値における差異は次のとおりです。

    v1.0: リソース = `https://graph.microsoft.com`

    v2.0: スコープ = `https://graph.microsoft.com/User.Read`

"appidURI/スコープ" という形式 (例: https://mytenant.onmicrosoft.com/myapi/api.read ) で API の URI を使って、任意のリソース API のスコープを要求できます。

> 注: MS Graph API の場合、スコープの値 `User.Read` は https://graph.microsoft.com/User.Read にマップされ、どちらでも使用できます。

* **増分同意のための動的スコープ。**

    Azure AD v1.0 を使ってアプリケーションを構築するときは、ユーザーがログイン時に同意するよう、アプリケーションで必要なアクセス許可 (静的スコープ) の完全なセットを登録する必要がありました。  Azure AD V2.0 では、スコープ パラメーターを使用して、必要なときにアクセス許可を要求できます。 これらを **動的スコープ** といいます。 これにより、ユーザーは、スコープに増分同意を提供できます。 最初ユーザーにはアプリケーションへのサインインだけを行わせ、どのような種類のアクセスも必要としない場合、そうすることができます。 その後、ユーザーの予定表を読み取る機能が必要になった場合は、`acquireToken*` メソッドで予定表のスコープを要求してユーザーの同意を得ることができます。

    次に例を示します。

    ```JavaScript
    const tokenRequest = {
          scopes: ["User.Read", "Calendar.Read"],
    }

    myMsalObj.acquireTokenPopup(tokenRequest );
    ```

* **V1.0 API 用のスコープ**

    MSAL.js を使用して、V1.0 API のトークンを取得する場合は、スコープとして `.default` を API のアプリケーション ID URI に付加することで、API に登録されているすべての静的スコープを要求できます。

    次に例を示します。

    ```javaScript

    const tokenRequest = {
          scopes: [ appidURI + "/.default"],
    }

    acquireTokenPopup(tokenRequest);
    ```

* **トークンのバージョン**

    v1.0 と v2.0 の両方のトークンを取得し、MSAL.js を使用して V1.0 API に対して V1.0 トークンを使用できます。

詳しくは、[Azure AD v1.0 と v2.0 の比較](https://docs.microsoft.com/azure/active-directory/develop/active-directory-v2-compare)に関する記事をご覧ください。

## <a name="i-am-moving-from-msal-angular-0x-to-msal-angular-1x-what-should-i-know"></a>MSAL-Angular 0.x から MSAL-Angular 1.x に移行しています。 何を知っている必要がありますか?
[こちらの](https://github.com/AzureAD/microsoft-authentication-library-for-js/blob/dev/lib/msal-angular/docs/0.x-1.x-upgrade-guide.md)移行ガイドをご覧ください。

# <a name="authentication"></a>認証

## <a name="i-dont-understand-the-redirect-flow-how-does-the-handleredirectcallback-function-work"></a>リダイレクト フローのことを理解していません。 `handleRedirectCallback` 関数はどのように動作しますか?

ページからリダイレクトされると、戻ったときにアプリケーションのまったく新しいインスタンスが作成されるため、リダイレクト フローは混乱を招く可能性があります。 つまり、リダイレクト メソッドの呼び出しからは何も返すことができません。 実際には、ページがリダイレクトされ、ユーザーが資格情報を入力した後、アプリケーションにリダイレクトされて戻るときは URL ハッシュに応答が格納されています。

MSAL 構成パラメーターの `navigateToRequestUrl` プロパティが **true** に設定されている場合は、`loginRedirect` を呼び出したときにいたページに再びリダイレクトされます (ただし、そのページが `redirectUri` としても設定されていない場合)。 アプリケーションですべてのリダイレクトが完了すると、ハッシュが処理され、トークンはローカルのセッション ストレージにキャッシュされます。

`handleRedirectCallback()` を呼び出すと、`loginPopup` の `.then` および `.catch` 句で実行する場合と同様に、応答が処理された後で関数を実行できます。

リダイレクト フローの動作を確認するには、サンプルの 1 つ ([たとえばこちら](https://github.com/Azure-Samples/ms-identity-javascript-v2)) を確認してください。

## <a name="how-can-i-support-authentication-with-personal-microsoft-accounts-only"></a>個人の Microsoft アカウントのみで認証をサポートするにはどうすればよいですか?

単に、MSAL アプリの構成で `authority` を **コンシューマー** のテナント (例: https://login.microsoftonline.com/consumers ) に設定します。

## <a name="how-do-i-log-in-multiple-users-to-my-application"></a>複数のユーザーをアプリケーションにログインさせるにはどうすればよいですか?
Msal.js v1.x では、複数の同時ユーザーはサポートされていません。 このユース ケースをアプリでサポートする必要がある場合は、msal-browser ライブラリにアップグレードしてください。

ユーザーの切り替えは、次のように、`loginRedirect` または `loginPopup` を呼び出して、要求に `prompt: "select_account"` を含めることで可能です。
```javascript
request = {
    scopes: [User.Read],
    prompt: "select_account"
}
```
ユーザーを切り替えるときは、ローカルのセッション ストレージからは前のユーザーのトークンがクリアされますが、AAD ではそのセッションがアクティブなままになる可能性があることに注意してください。 ユーザーを切り替える前に `logout()` を呼び出すことをお勧めします。

# <a name="single-sign-on"></a>シングル サインオン

## <a name="how-to-get-single-sign-on-in-my-application-with-msaljs"></a>MSAL.js を使用してアプリケーションにシングル サインオンするにはどうすればよいですか?

[シングル サインオン](https://docs.microsoft.com/azure/active-directory/develop/msal-js-sso)に関するドキュメントを読んで、MSAL.js でシングル サインオンを使用できるさまざまなシナリオについて学習してください。

## <a name="how-can-my-application-recognize-a-user-after-sign-in-how-do-i-correlate-users-between-applications"></a>サインイン後のユーザーをアプリケーションで認識するにはどうすればよいですか? アプリケーション間でユーザーを関連付けるにはどうすればよいですか?

`AuthResponse` の Account で `accountIdentifier` プロパティを使用できます。

```js
loginPopup().then((response) => {
    const uniqueID = response.account.accountIdentifier;
})
```

# <a name="configuration"></a>構成

## <a name="how-do-i-decide-what-to-set-as-my-redirecturi"></a>`redirectUri` として設定するものを決定するにはどうすればよいですか?

`redirectUri` は、認証が完了したときにリダイレクトして戻る先を IDP に伝えるために、MSAL インスタンスや個々の要求に対して提供できるパラメーターです。 `redirectUri` として設定するものを決定するときは、いくつかの点に留意する必要があります

`redirectUri` を明示的に指定しないと、MSAL は現在のページを `redirectUri` として使います

**注:**  すべての `redirectUris` は、アプリケーションの Azure アプリ ポータルに登録されている必要があり、すべてのハッシュやクエリ パラメーターなどと完全に一致する必要があります

### <a name="when-using-a-redirect-api"></a>Redirect API を使う場合

`loginRedirect`, `acquireTokenRedirect`

リダイレクト API を使ってトークンを取得するときは、`redirectUri` のページに加えて、最終的に応答を処理するページで、ログインを完了したりトークンをキャッシュしたりするために MSAL を初期化する必要があります。 また、MSAL による応答の処理が正常に **終了する** まで、このページで URL 内のハッシュが操作されないことも確認してください。

- MSAL の認証構成で `navigateToLoginRequestUrl: false` が指定されている場合、指定されている `redirectUri` が最後のページになり、そこで応答が処理されます。
- `navigateToLoginRequestUrl: true` (既定値) の場合は、IDP は指定された `redirectUri` にリダイレクトし、そこから要求を開始したページに **再び** リダイレクトします。 この最後のページで応答が処理されます。

**注:**  アプリ ポータルに登録する必要があるのは、`redirectUri` に渡される URL のみです。 `navigateToLoginRequestUrl: true` の場合は、要求で別の `redirectUri` を指定している限り、`redirectUri` として要求している URL をアプリ ポータルに登録する必要はありません。

### <a name="when-using-a-popup-or-silent-api"></a>Popup API または Silent API を使う場合

`loginPopup`, `acquireTokenPopup`, `ssoSilent`, `acquireTokenSilent`

ポップアップまたはサイレント API を使ってトークンを取得するときは、認証を必要とせず、MSAL を初期化しない空白のページに、`redirectUri` を設定することをお勧めします。 これは、ポップアップ ウィンドウで資格情報または同意が求められ、親アプリで応答が解析されるためです。 同様に、サイレント シナリオの非表示の iframe は IDP にリダイレクトし、`redirectUri` にリダイレクトして戻ります。 ポップアップまたは非表示の iframe でアプリをレンダリングする必要はありません。実際、パフォーマンスの低下、閉じられないポップアップ、トークンの更新タイムアウト、その他の、予期しない問題が発生する可能性があります。

```javascript
request = {
    scopes: ["User.Read"],
    redirectUri: "http://myapp.com/blank.html"
}
```

## <a name="how-do-i-pass-custom-state-parameter-value-in-msaljs-authentication-request-for-example-when-you-want-to-pass-the-page-the-user-is-on-or-custom-info-to-your-redirect_uri"></a>MSAL.js 認証要求でカスタム状態パラメーターの値を渡すにはどうすればよいですか? 次に例を示します。ユーザーがいるページまたはカスタム情報を `redirect_uri` に渡すとき。

OAuth 2.0 で定義されている状態パラメーターは、要求に含まれる値であり、**クロスサイト リクエスト フォージェリ** 攻撃を防ぐために通常使用されるトークン応答でも返されます。 既定では、MSAL.js は、この目的のためにランダムに生成される一意の `state` 値を認証要求で渡します。

このパラメーターは、リダイレクトの前に、アプリの状態の情報をエンコードするために使用することもできます。 アプリ内のユーザーの状態 (ユーザーがいたページやビューなど) を、このパラメーターへの入力として渡すことができます。

MSAL.js ライブラリを使うと、カスタムの状態を Request オブジェクトの `state` パラメーターとして渡すことができます。

```javascript
// Request type
export type AuthenticationParameters = {
    scopes?: Array<string>;
    extraScopesToConsent?: Array<string>;
    prompt?: string;
    extraQueryParameters?: QPDict;
    claimsRequest?: string;
    authority?: string;
    state?: string;
    correlationId?: string;
    account?: Account;
    sid?: string;
    loginHint?: string;
};
```

次に例を示します。

```javascript
let loginRequest = {
    scopes: ["user.read", "user.write"],
    state: “page_url”
}

myMSALObj.loginPopup(loginRequest);
```

渡された状態は、要求の送信時に、MSAL.js によって設定される一意の `GUID` に追加されます。 応答が返されると、MSAL.js により状態が一致しているかどうか確認され、Response オブジェクトで渡されたカスタムの状態が `accountState` として返されます。

```javascript
export type AuthResponse = {
    uniqueId: string;
    tenantId: string;
    tokenType: string;
    idToken: IdToken;
    accessToken: string;
    scopes: Array<string>;
    expiresOn: Date;
    account: Account;
    accountState: string;
};
```

## <a name="what-is-the-difference-between-sessionstorage-and-localstorage"></a>`sessionStorage` と `localStorage` の違いは何ですか?

Microsoft は、MSAL 用の 2 つの保存法である `localStorage` と `sessionStorage` を提供しています。  ユーザーが取得したトークンをより安全に格納できるため、`sessionStorage` を使用することが推奨されます。ただし、`localStorage` を使用すると、タブとユーザー セッションをまたいだシングル サイン オンを実行できるようになります。  オプションを検討し、アプリケーションに最適な決定を行うことをお勧めします。

## <a name="where-is-the-authority-domain-string-on-azure-ad-portal"></a>`authority` ドメインの文字列は Azure AD ポータルのどこにありますか?

MSAL アプリ構成に代わって必要な `authority` 文字列は、`Azure Portal/AzureAD/App Registration/Overview` ページの **[エンドポイント]** のリンクの一覧には明示的に示されません。 これは単に、`/token` または `/authorize` エンドポイントのドメイン部分の後に、テナント名または ID が付いたものです (例: `https://login.microsoftonline.com/common`)。

# <a name="tokens"></a>トークン

## <a name="how-do-i-renew-tokens-with-msaljs"></a>MSAL.js でトークンを更新するにはどうすればよいですか?

MSAL.js の `acquireTokenSilent` メソッドは、ユーザーにプロンプトを表示せずに暗黙的にトークン要求を行うことで、トークンの更新を処理します。 このメソッドは、最初に、ブラウザー ストレージ内にキャッシュされた有効なトークンを検索します。 見つからない場合、ライブラリは Azure AD に暗黙的な要求を行い、アクティブなユーザー セッションがある場合 (Azure AD ドメインのブラウザーで設定された Cookie によって判断されます)、新しいトークンが返されます。 ライブラリは `acquireTokenSilent` メソッドを自動的に呼び出しません。 API 呼び出しを行って有効なトークンを取得する前に、アプリで `acquireTokenSilent` を呼び出すことをお勧めします。

トークンを暗黙的に取得する `acquireTokenSilent` メソッドの試みが失敗する場合があります。 たとえば、Azure AD とのユーザー セッションの有効期限が切れている場合や、ユーザーがパスワードを変更する場合などで、ユーザーの対話式操作が必要になります。 `acquireTokenSilent` が失敗した場合は、対話式のトークン取得メソッドのいずれかを呼び出す必要があります (`acquireTokenPopup` または `acquireTokenRedirect`)。

Azure AD によって返されるトークンの既定の有効期間は 1 時間です。 ただし、ユーザーがアプリケーションでアクティブになっていて、有効な Azure AD セッションがブラウザーに存在する限り、`acquireTokenSilent` メソッドを使ってトークンを更新できます。 Azure AD セッションは 24 時間有効であり、ユーザーがサインイン画面で [サインインしたままにする] オプションを選ぶことで延長できます。 詳しくは、[トークンとセッションの有効期間](https://docs.microsoft.com/azure/active-directory/develop/active-directory-configurable-token-lifetimes)に関するドキュメントをご覧ください。

## <a name="how-can-i-acquire-tokens-faster"></a>トークンをより速く取得するにはどうすればよいですか?

[こちら](https://github.com/AzureAD/microsoft-authentication-library-for-js/blob/dev/lib/msal-core/docs/performance.md)のパフォーマンス ガイドをご覧ください

## <a name="how-long-do-tokens-last-how-long-are-they-valid-for"></a>トークンはどれくらいの間存在していますか? その有効期間はどれくらいですか?

トークンの有効期間は 1 時間で、セッションの有効期間は 24 時間です。 つまり、24 時間以内に要求が行われなかった場合は、新しいトークンを要求する前にログインし直す必要があります。

## <a name="why-is-the-accesstoken-field-in-the-response-empty"></a>応答の accessToken フィールドが空になっているのはなぜですか?

スコープ `clientId`、`openid`、`profile` を要求している場合、これらは **ID トークン** スコープです。 1\.4.0 より前のバージョンの MSAL.js は、**ID トークン** を取得し、それを `accessToken` フィールドと `idToken` フィールド (両方とも同じ値) に格納していました。 バージョン 1.4.0 において、この動作は AAD/B2C サーバーが返送しているものと一致するように変更されました。 現在の MSAL.js は、同じ **ID トークン** を取得しますが、それを `idToken` フィールドに格納し、`accessToken` フィールドは空のままにします。 アクセス トークンが必要な場合は、`clientId`、`openid`、または `profile` 以外のスコープを要求する必要があります

詳しくは、[スコープに関するドキュメント](https://github.com/AzureAD/microsoft-authentication-library-for-js/blob/dev/lib/msal-core/docs/scopes.md)をご覧ください。

# <a name="scopes--resources"></a>スコープとリソース

## <a name="my-application-has-multiple-resources-it-needs-to-access-to-how-should-i-handle-scopes-for-access-tokens"></a>アプリケーションで複数のリソースにアクセスする必要があります。 アクセス トークンのスコープをどのように処理する必要がありますか?

リソースとスコープに関する[こちら](https://github.com/AzureAD/microsoft-authentication-library-for-js/blob/dev/lib/msal-browser/docs/resources-and-scopes.md)のドキュメントをご覧ください

## <a name="in-the-samples-i-see-scopes-passed-in-loginrequest-and-tokenrequest-objects-what-is-the-difference-between-passing-scopes-during-login-vs-passing-scopes-during-token-acquisition"></a>サンプルでは、スコープが `loginRequest` オブジェクトと `tokenRequest` オブジェクトに渡されています。 ログインの間にスコープを渡すのと、トークンの取得の間にスコープを受すのでは、何が違いますか?

違うのは、ユーザーが同意を求められるステージです。

次の点を考慮してください。

```JavaScript
const loginRequest = {
  scopes: ["User.Read"]
};

const tokenRequest = {
  scopes: ["Mail.Read"]
};

msalInstance.loginPopup(loginRequest);
// ...

msalInstance.acquireTokenSilent(tokenRequest);
// ...
```

上のコード スニペットでは、ユーザーは認証の後で `User.Read` スコープに同意します。 後でユーザーが `User.Read` に対する `access_token` を要求する場合、もう一度同意を求められることはありません (つまり、**暗黙的に** トークンを取得できます)。 これに対し、ユーザーは認証の段階で `Mail.Read` に同意しませんでした。 その場合、ユーザーがそのスコープに対して `access_token` を要求すると、同意を求められます。 

この件について詳しくは、[アクセス許可と同意](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent)に関するドキュメントをご覧ください

## <a name="im-seeing-scopes-openid-profile-email-offline_access-and-userread-in-my-tokens-even-though-i-havent-requested-them-what-are-they"></a>要求していないにもかかわらず、トークンにスコープ `openid`、`profile`、`email`、`offline_access`、`User.Read` が含まれます。 それらは何ですか?

最初の 4 つ (`openid`、`profile`、`email`、`offline_access`) は、**既定のスコープ** と呼ばれます。 これらは、Azure AD - OAuth 2.0/OpenID Connect コンプライアンスの一部として Azure AD に追加されます。 これらは特定の API の一部では **ありません**。 これらについて詳しくは、[こちら](https://openid.net/specs/openid-connect-core-1_0.html)をご覧ください。 

一方、スコープ `User.Read` は MS Graph API のスコープです。 また、すべてのアプリ登録に既定で追加されます。 ただし、アプリケーションで MS Graph API を呼び出していない場合は、無視するだけでかまいません。

# <a name="tenancy--audience"></a>テナントと対象ユーザー

## <a name="what-do-i-need-to-make-my-app-multi-tenant"></a>アプリをマルチテナントにするには、何を行う必要がありますか?

[MSAL.js マルチテナント アプリケーションのサンプル](https://github.com/Azure-Samples/ms-identity-javascript-angular-spa-aspnet-webapi-multitenant)をご覧ください。

## <a name="how-do-i-provide-admin-consent-for-an-app-that-has-no-user-interaction-capability-like-a-web-api"></a>Web API のようにユーザーの対話式操作機能を持たないアプリに管理者の同意を提供するにはどうすればよいですか?

これに対する解決策としては、ユーザー (この場合は管理者ユーザー) が、フロントエンド アプリケーションに同意するのと同時に、Web API に同意できるようにします。つまり、"組み合わせ同意" を提供します。 `/.default` スコープをこの効果に使用でき、1 つのステップで多くの異なるスコープに同意できます。 

> **既定のスコープ**:これは、アプリケーション登録で構成されたアクセス許可の静的一覧を参照するすべてのアプリケーションの組み込みスコープです。 基本的に、それによってすべてのアクセス許可が 1 つのスコープにバンドルされます。 `/.default` スコープは、任意の OAuth 2.0 フローで使用できますが、v2.0 の `/adminconsent` エンドポイントを使ってアプリケーションのアクセス許可を要求するときは必須です。

残りの問題は、一部の外部アプリケーションではなく、認識されたフロントエンド アプリケーションから同意が得られたことを Web API が認識するように構成することです。 このためには、`KnownClientApplications` 機能を使用できます。

> **KnownClientApplications**: アプリケーション マニフェストの属性。 2 つ以上の部分 (クライアント アプリとカスタム Web API) を含むソリューションがある場合に、同意をバンドルするために使われます。 この配列にクライアント アプリの appID (clientID) を入力すると、ユーザーは、クライアント アプリに 1 回同意するだけで済みます。 クライアントへの同意が Web API への暗黙的な同意を意味することが Azure AD によって認識されます。 クライアントと Web API の両方のサービス プリンシパルが同時に自動的にプロビジョニングされます。 クライアントと Web API アプリの両方が同じテナントに登録されている必要があります。

これを使用するには、アプリケーション マニフェスト (Azure Portal/アプリ登録) で KnownClientApplications を見つけて、クライアント アプリケーション `KnownClientApplications: ["your-client-id-for-client-application"]` のアプリケーション (クライアント) ID を追加します。 それを行うと、Web API でフロントエンドを正しく識別できるようになり、組み合わせ同意が正常に実行されます。

## <a name="what-are-the-differences-between-supported-audiences-and-account-types"></a>サポートされる対象ユーザーとアカウントの種類の違いは何ですか?

「[Azure Active Directory のテナント](https://docs.microsoft.com/azure/active-directory/develop/single-and-multi-tenant-apps#who-can-sign-in-to-your-app)」をご覧ください

# <a name="b2c"></a>B2C

## <a name="my-b2c-application-has-more-than-one-user-flowpolicy-how-do-i-work-with-multiple-policies-in-msaljs"></a>B2C アプリケーションに複数のユーザー フローとポリシーがあります。 MSAL.js で複数のポリシーを使用するにはどうすればよいですか?

MSAL.js では、要求ごとに機関を提供できます。 サインインで使ったポリシーとは異なるポリシーのアクセス トークンを取得するには、要求オブジェクトの一部として関連機関を渡すだけです。

```javascript
const request = {
scopes: ["https://b2ctenant.onmicrosoft.com/exampleApi/exampleScope"],
authority: "https://b2ctenant.b2clogin.com/b2ctenant.onmicrosoft.com/examplePolicy"
}

msal.acquireTokenPopup(request);
```

複数のポリシーのシナリオに関しては、留意すべきことが他にいくつかあります。

- MSAL.js 1.x は、一度に 1 つの id_token だけをキャッシュできます。つまり、異なるポリシーの id_token を取得すると、前のポリシーからキャッシュされた id_token は上書きされます。
- profile_edit や password_reset などの一部のポリシーでは、対話式操作が必要であり、暗黙的なトークンの更新には使用できません。 キャッシュされたアクセス トークンの `acquireTokenSilent` による取得はやはり可能ですが、トークンの有効期限が切れた場合は、MSAL が更新を試みると、サービスで "X-Frame Options DENY" エラーがスローされます。 これが発生する場合は、アプリケーションでこのエラーをキャッチし、対話型メソッド (`acquireTokenRedirect` または `acquireTokenPopup`) の呼び出しにフォールバックする必要があります

## <a name="how-can-i-implement-password-reset-user-flow-in-my-b2c-application-with-msaljs"></a>MSAL.js を使用して B2C アプリケーションにパスワード リセット ユーザー フローを実装するにはどうすればよいですか?

**パスワード リセット** ユーザー フローを実装する方法については、[こちら](https://github.com/Azure-Samples/active-directory-b2c-javascript-msal-singlepageapp)のサンプルを確認してください。

## <a name="i-logged-out-of-my-application-why-am-i-not-asked-for-credentials-when-i-try-to-log-back-in"></a>アプリケーションからログアウトしました。 ログインし直そうとしたときに資格情報の入力を求められないのはなぜですか?

MSAL の `logout()` API を呼び出して B2C アプリケーションからログアウトすると、MSAL.js は最初にユーザーのトークンのブラウザー ストレージをクリアしてから、Azure B2C のログアウト エンドポイントにリダイレクトします。 その後、B2C サービスはセッションを閉じますが、ユーザーをフェデレーション IDP からログアウトしない場合があります。 このようになるのは、ユーザーがログアウトを望んでいる可能性がある他のアプリについて、サービスが何も想定しないためです。 これは実際には、ユーザーが再度ログインしようとすると、B2C サービスはユーザーにサインインするソーシャル IDP の選択を求めることを意味します。 ユーザーが選択を行うと、対話式操作なしで再びサインインする可能性があります。

この動作について詳しくは、[こちら](https://docs.microsoft.com/azure/active-directory-b2c/session-overview#sign-out)をご覧ください

## <a name="why-am-i-not-signed-in-when-returning-from-an-invite-link"></a>招待リンクから戻るときにサインインしていないのはなぜですか?

MSAL.js は、最初に要求したトークンのみを処理します。 フローで、サインアップに使用できるリンクをユーザーに送信する必要がある場合は、そのリンクが B2C サービスを直接指しているのではなく、アプリを指していることを確認する必要があります。 フローの例は、[B2C の使用](https://github.com/AzureAD/microsoft-authentication-library-for-js/blob/dev/lib/msal-browser/docs/working-with-b2c.md)に関するドキュメントで確認できます。

## <a name="what-should-i-do-if-i-believe-my-issue-is-with-the-b2c-service-itself-rather-than-with-the-library"></a>問題がライブラリではなく B2C サービス自体にあると思われる場合はどうすればよいですか?

その場合は、次の手順に従って、B2C チームにサポート チケットを提出してください: [B2C サポート オプション](https://docs.microsoft.com/azure/active-directory-b2c/support-options)。

# <a name="common-issues"></a>一般的な問題

## <a name="how-to-avoid-page-reloads-when-acquiring-and-renewing-tokens-silently"></a>トークンを自動的に取得して更新するときに、ページが再度読み込まれないようにするにはどうすればよいですか?

MSAL.js は、非表示の iframe を使って、バックグラウンドで暗黙的にトークンを取得して更新します。 Azure AD は、トークン要求で指定されている登録済みの `redirect_uri` にトークンを戻します。 応答は 302 なので、結果は iframe に読み込まれる `redirect_uri` に対応する HTML になります。 通常 (既定では)、アプリの `redirect_uri` はルート ページであり、これにより再度読み込まれます。

それ以外の場合として、アプリのルート ページへの移動で認証が要求されると、**入れ子になった iframe** または **XFRAME DENY エラー** になる可能性があります。

MSAL.js は Azure AD によって発行された 302 を無視できず、返されたトークンを処理する必要があるため、`redirect_uri` が iframe に読み込まれるのを回避することはできません。

アプリ全体の再読み込みやこれにより発生するその他のエラーを回避するには、次の回避策に従ってください。

* **iframe に別の HTML を指定する:**

    構成の `redirect_uri` プロパティを、認証を必要としない単純なページに設定します。 Azure portal に登録された `redirect_uri` と一致することを確認する必要があります。 ユーザーがログイン プロセスを開始し、ログインが完了した後に正確な場所にリダイレクトされたときに MSAL によりスタート ページが保存されるため、ユーザーのログイン エクスペリエンスに影響は出ません。

* **メイン アプリ ファイルでの条件付きの初期化:**

    アプリの初期化、ルーティングなどを定義する中央の単一 JavaScript ファイルが存在するようにアプリが構成されている場合、アプリが iframe に読み込まれるかどうかに基づいてアプリ モジュールを条件付きで読み込むことができます。 次に例を示します。

    *AngularJS: app.js の場合*
    ```js

    // Check that the window is an iframe and not popup
    if (window !== window.parent && !window.opener) {
    angular.module('todoApp', ['ui.router', 'MsalAngular'])
        .config(['$httpProvider', 'msalAuthenticationServiceProvider','$locationProvider', function ($httpProvider, msalProvider,$locationProvider) {
            msalProvider.init(
                // msal configuration
            );

            $locationProvider.html5Mode(false).hashPrefix('');
        }]);
    }
    else {
        angular.module('todoApp', ['ui.router', 'MsalAngular'])
            .config(['$stateProvider', '$httpProvider', 'msalAuthenticationServiceProvider', '$locationProvider', function ($stateProvider, $httpProvider, msalProvider, $locationProvider) {
                $stateProvider.state("Home", {
                    url: '/Home',
                    controller: "homeCtrl",
                    templateUrl: "/App/Views/Home.html",
                }).state("TodoList", {
                    url: '/TodoList',
                    controller: "todoListCtrl",
                    templateUrl: "/App/Views/TodoList.html",
                    requireLogin: true
                })

                $locationProvider.html5Mode(false).hashPrefix('');

                msalProvider.init(
                    // msal configuration
                );
            }]);
    }
    ```

    *Angular: app.module.ts の場合*

    ```js
    // Imports...
    @NgModule({
      declarations: [
        AppComponent,
        MsalComponent,
        MainMenuComponent,
        AccountMenuComponent,
        OsNavComponent
      ],
      imports: [
        BrowserModule,
        AppRoutingModule,
        HttpClientModule,
        ServiceWorkerModule.register('ngsw-worker.js', { enabled: environment.production }),
        MsalModule.forRoot(environment.MsalConfig),
        SuiModule,
        PagesModule
      ],
      providers: [
        HttpServiceHelper,
        {provide: HTTP_INTERCEPTORS, useClass: MsalInterceptor, multi: true},
        AuthService
      ],
      entryComponents: [
        AppComponent,
        MsalComponent
      ]
    })
    export class AppModule {
      constructor() {
        console.log('APP Module Constructor!');
      }

      ngDoBootstrap(ref: ApplicationRef) {
        if (window !== window.parent && !window.opener)
        {
          console.log("Bootstrap: MSAL");
          ref.bootstrap(MsalComponent);
        }
        else
        {
        //this.router.resetConfig(RouterModule);
          console.log("Bootstrap: App");
          ref.bootstrap(AppComponent);
        }
      }
    }
    ```
    *MsalComponent:*

    ```js
    import { Component} from '@angular/core';
    import { MsalService } from '@azure/msal-angular';

    // This component is used only to avoid Angular reload
    // when doing acquireTokenSilent()

    @Component({
      selector: 'app-root',
      template: '',
    })
    export class MsalComponent {
      constructor(private Msal: MsalService) {
      }
    }
    ```

## <a name="why-is-my-application-stuck-in-an-infinite-redirect-loop"></a>アプリケーションが無限リダイレクト ループでスタックするのはなぜですか?

リダイレクトのループは、ほとんどの場合、ページの読み込み時にアプリで `loginRedirect` の呼び出しを自動的にトリガーするときに発生します。 アプリでは、ログインを試みる前にまず、ユーザーがサインインしていることを確認する必要があります。

```javascript
if (!msalObj.getAccount()) {
    msalObj.loginRedirect(request);
} else {
    // User signed in!
}
```

### <a name="solutions"></a>ソリューション

- msal-angular を使っていて、アプリがブロードキャスト イベントに依存している場合は、トークンを含む応答を処理するページでアプリが `handleRedirectCallback()` を呼び出していることを確認します。
- MSAL の構成で `navigateToLoginRequestUrl: false` を設定します。これが true に設定されている場合、IDP は構成されている `redirectUri` にリダイレクトし、MSAL はログイン要求を開始したページにさらにリダイレクトします。 これを false に設定すると、ナビゲーションは `redirectUri` に達した時点で終了します

```javascript
msal = new Msal.UserAgentApplication({
    auth: {
        clientId: your-client-id,
        redirectUri: your-redirect-uri
        navigateToLoginRequestUrl: false
    }
});
```

- MSAL が応答ハッシュを解析する前に、アプリでそれをクリアしないようにしてください。 
- ネットワーク トレースで、/authorize 要求への応答を調べます。 それに `id_token` が含まれているのに、アプリで別のログインをトリガーしている場合は、アプリのロジックを確認します
- IE11 または Chromium 以外の Edge ブラウザーを使っている場合は、MSAL のキャッシュ構成で `storeAuthStateInCookie: true` を設定します

```javascript
msal = new Msal.UserAgentApplication({
    auth: {
        clientId: your-client-id,
    },
    cache: {
       storeAuthStateInCookie: true 
    }
})
```

## <a name="im-using-one-of-your-samples-on-internet-explorer-and-i-get-the-error-signin-is-not-defined"></a>Internet Explorer でサンプルの 1 つを使用していると、"SignIn() が定義されていない" というエラーが発生します

サンプルでは [ES6](http://www.ecma-international.org/ecma-262/6.0/) の規則 (具体的には、**Promise**、**アロー関数**、**テンプレート リテラル**) を使用します。 そのため、Internet Explorer ではそのままでは動作 **しません**。 **Promise** の場合は、次のようにポリフィルを追加する必要があります。

```html
<head>
   <!-- adding pollyfil for promises on IE11  -->
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/js-polyfills/0.1.42/polyfill.min.js"> 
   </script>
</head>
```

**アロー関数** と **テンプレート リテラル** の場合は、古い JavaScript にトランスパイルする必要があります。 [このツール](https://babeljs.io/repl)を使うとそのプロセスに役立ちます。
