---
ms.openlocfilehash: ab5d7ec15a40676d02632334cb8ea86ff39742e8
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/05/2022
ms.locfileid: "145884336"
---
# <a name="errors"></a>エラー

1. ['X-Frame-Options' を 'DENY' に設定したので、フレーム内の ... を表示することを拒否されました](#Refused-to-display-...-in-a-frame-because-it-set-'X-Frame-Options'-to-'DENY')
1. [タイムアウトが原因でトークン更新操作が失敗しました](#Token-Renewal-Operation-failed-due-to-timeout)
1. [ハッシュに状態が含まれていません](#Hash-does-not-contain-state)
1. [AADSTS50058:サイレント サインイン要求が送信されましたが、ユーザーはサインインしていません](#AADSTS50058:-A-silent-sign-in-request-was-sent-but-no-user-is-signed-in)

## <a name="refused-to-display--in-a-frame-because-it-set-x-frame-options-to-deny"></a>'X-Frame-Options' を 'DENY' に設定したので、フレーム内の ... を表示することを拒否されました

このエラーは、トークンの更新を実行するために非表示の iframe を開く `acquireTokenSilent` を呼び出すと発生します。 クリックジャックを防ぐため、このサービスは認証ページを iframe 内に表示しないようブロックしています。 このエラーを受け取る場合、フォームなどのユーザーの対話式操作を必要とするエラーやページをサービスが iframe 内に表示しようとしていることを意味します。

一部の B2C フローはユーザーの対話式操作が必要なので、このエラーがスローされると予想されます。 次のようなフローがあります。

- パスワードのリセット
- プロファイルの編集
- サインアップ
- 構成方法によっては、いくつかのカスタム ポリシーがあります。

### <a name="troubleshooting-steps"></a>トラブルシューティングの手順

- 対話式操作が必要なフローを使っていないことを確認します
- エラーに表示された URL を新しいウィンドウで開き、サービスが表示しようとしている内容を確認します

### <a name="solutions"></a>ソリューション

- エラーに表示された URL を新しいウィンドウで開き、エラーが表示された場合は、そのエラーに対処します
- `acquireTokenRedirect` や `acquireTokenPopup` のような対話式メソッドを呼び出します
- そのサービスに関するチケットを開きます

### <a name="known-issues"></a>既知の問題

ユーザーがソーシャル プロバイダー (Google、Facebook など) に複数のアカウントでログインした状態になります。 これが起こる理由は、トークンを取得しようとしているアカウントをフェデレーション IDP に伝えるための login_hint が、B2C サービスからソーシャル プロバイダーに渡されていないからです。 エラーの URL を新しいタブで開き、アカウント選択画面が表示されたら、これが発生している可能性があります。 これについては、B2C サービス チームが積極的に調査しています。

## <a name="token-renewal-operation-failed-due-to-timeout"></a>タイムアウトが原因でトークン更新操作が失敗しました

このエラーは、トークンの更新を実行するために非表示の iframe を開く `acquireTokenSilent` を呼び出すと発生します。 これは、次のようないくつかの原因で発生することがあります。

- サードパーティの Cookie が無効になっています (Safari と Chrome のシークレット ブラウザーの既定値)
- X-Frame Options Deny など、別のエラーが発生し、トークンが返されませんでした
- `redirectUri` として使われたページで、ハッシュがクリアされたか、上部のフレームが解析する前に移動してしました

### <a name="solutions"></a>ソリューション

- サードパーティの Cookie を無効にしたブラウザーを使っている場合は、`acquireTokenRedirect` や `acquireTokenPopup` などの対話式メソッドを呼び出す必要があります
- 付随するエラーを解決します
- `acquireTokenSilent` の呼び出しに `redirectUri` を空のページに設定します

## <a name="hash-does-not-contain-state"></a>ハッシュに状態が含まれていません

このエラーが発生するのは、`id_token` のような msal に認識されるプロパティが URL のハッシュに含まれているにもかかわらず、`state` が含まれない場合です。 `state` プロパティは、msal によってトークン要求に付加され、応答を受け取ったときに検証されます。 このエラーの最も一般的な原因は、要求が msal によって構築されていない招待リンクから送信されたことです。

### <a name="troubleshooting-steps"></a>トラブルシューティングの手順

- ネットワーク トレースで、/authorize 要求を確認します
- 要求に `state` が含まれていることを確認します
- 応答に `state` が含まれていることを確認します
- 要求に `state` が含まれていない場合、要求が msal によって構築されたことを確認します
- 要求に `state` が含まれている場合、チケットを開き、応答で返されない理由を確認するようにサービス チームに依頼してください

### <a name="solutions"></a>ソリューション

- 招待リンクを使う場合は、まずユーザーを msal が動作するアプリに送信し、msal がトークン要求を構築するようにします。 サインアップ フローを完成させるために追加のクエリ パラメーターが必要な場合は、要求の `extraQueryParameters` に含めることができます

## <a name="aadsts50058-a-silent-sign-in-request-was-sent-but-no-user-is-signed-in"></a>AADSTS50058:サイレント サインイン要求が送信されましたが、ユーザーはサインインしていません

このエラーが発生するのは、新しい `access_token` または `id_token` を取得するために MSAL.js から Azure AD にサイレント要求 (`acquireTokenSilent`) を送信しましたが、要求と共に送信されたユーザー セッションを表す有効な認証 Cookie がない場合です。 その結果、Azure AD はユーザーを特定できず、前述のエラーを返します。 Cookie が存在しない原因として、次のいずれかの理由が考えられます。

* **Cookie の期限切れ**:ユーザーがログインしたときに Azure AD がブラウザーに設定した認証 Cookie が期限切れになったか、削除された場合。 通常、Cookie は閲覧セッションが有効になるまで有効です。つまり、ブラウザーを閉じたり、長時間アイドル状態のままにすると、Cookie が削除されるか、期限切れになる可能性があります。  

**解決方法:** 認証セッションを長時間維持する必要がある場合、ユーザーはサインイン画面で [Keep Me Signed In] \(サインインしたままにする\) チェックボックスをオンにする必要があります。 そうしなかった場合、アプリケーションで新しいセッションを作成するには、ユーザーの再ログインを実行する必要があります。

* **IE または Edge の使用**:MSAL.js のサイレント トークン取得は、非表示の iframe を使って行われます。 IE と Edge には、iframe とメイン アプリのドメインが異なるセキュリティ ゾーンにある場合に iframe で Cookie を送信しないセキュリティ ゾーンがあります。 つまり、アプリのドメインと Azure AD の権限 URL が異なるセキュリティ ゾーンにある場合、ブラウザーから iframe の要求で Azure AD の Cookie が送信されません。
  
**解決方法:** アプリと Azure AD `authority` URL の両方を、ブラウザーの設定で同じセキュリティ ゾーンに追加する必要があります。

* **サードパーティの Cookie がブロックされる**:サードパーティの Cookie がブラウザーでブロックされる場合、Cookie はトークン要求で送信されません。 
 
**解決方法:** MSAL.JS サイレント要求が期待どおりに機能するには、ユーザー (または管理者) がサードパーティ Cookie を許可する必要があります。

### <a name="known-issues"></a>既知の問題

- ゲスト アカウントを使っている場合、サインインに使われるメール アドレスが、AAD にアカウントを格納するために使われているメール アドレスと一致しない場合があります。その結果、正しくない `login_hint` が要求の一部として msal によって送信されます。 `sid` クレームを `id_tokens` 上で構成し、これを要求に渡すと、この問題が軽減される場合があります。

### <a name="other-potential-solutions"></a>その他の考えられる解決策

- `acquireTokenSilent` を呼び出す前に、アプリがログイン メソッド `loginRedirect` または `loginPopup` のいずれかを呼び出していることを確認します
- `acquireTokenRedirect` や `acquireTokenPopup` のような対話式メソッドを呼び出します
- `sid` クレームを返し、これを要求に渡すように `id_tokens` を構成します 

```javascript
// id_token retrieved from previous login or acquireToken call
const request = {
    scopes: ["User.Read"],
    sid: id_token.sid
}
msalObj.acquireTokenSilent(request)
```
