---
ms.openlocfilehash: d99a852de287c3a30a13613df40d74a22ad70ceb
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/05/2022
ms.locfileid: "145884266"
---
# <a name="scope-configuration-and-behavior"></a>スコープの構成と動作

## <a name="contents"></a>内容
* [クイック リファレンス](#quick-reference)
* [スコープ](#scopes)
    * [スコープ関数](#scope-functions)
    * [スコープの種類](#scope-types)
        * [認可のリソース スコープ](#resource-scopes-for-authorization)
        * [認証の OpenID Connect スコープ](#openid-connect-scopes-for-authentication)
* [スコープの動作](#scopes-behavior)
    * [認可要求での既定のスコープ](#default-scopes-on-authorization-requests)
    * [特別な OIDC スコープの動作ケース](#special-oidc-scopes-behavior-cases)

## <a name="quick-reference"></a>クイック リファレンス

> このセクションでは、詳細には触れずに、このドキュメントが扱う主要なポイントの概要について説明します。 `msal@1.x` のスコープの機能と動作について、より明確な説明や情報が必要な場合は、このドキュメントの残りの部分をお読みください。

`msal@1.x` がスコープを処理して使う方法の重要なポイントは次のとおりです。

1. `msal@1.x` ライブラリは、すべての送信要求において、常に `openid` と `profile` をスコープとして付加します。
2. アプリケーションの ClientId の値を唯一のスコープとして設定すると、`openid` と `profile` に置き換えられ、ID Token が返されます

この 2 つの特定の動作にまつわる根拠や意義についてもっと知りたい場合は、続けてお読みください。



## <a name="scopes"></a>スコープ

OAuth 2.0 プロトコル仕様に準拠して `msal@1.x` が取得する Microsoft ID プラットフォーム アクセス トークンは、特定のリソースのユーザーの代わりに認可されている証明としてアプリケーションに発行されます。 このトークンの発行は、`audience` やアプリケーションに固有のものだけでなく、`scopes` やアクセス許可の集合に固有のものでもあります。

### <a name="scope-functions"></a>スコープ関数

#### <a name="function-of-scopes-in-oauth-20"></a>OAuth 2.0 におけるスコープの機能

[OAuth 2.0 アクセス トークン スコープ リファレンス](https://tools.ietf.org/html/rfc6749#section-3.3)による `scopes` 構成の主な機能は、アプリケーションがユーザーに代わって `authorization` を要求する権限を決定することです。 上記の機能は、`msal@1.x` と Microsoft ID プラットフォーム一般によってサポートされ、カバーされています。 認可スコープの通常の機能の詳細については、公式の [Microsoft ID プラットフォーム ドキュメント](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent)を参照してください。

#### <a name="special-use-of-scopes-in-msal1x"></a>msal@1.x におけるスコープの特別な使い方

`scopes` のグローバルな概念と使い方に加えて、`msal@1.x` ではスコープに特別な使い方をすることで、スコープの設定の重要性を高めており、その理解が大切です。 つまり、`msal@1.x` を使うと、開発者は特定のスコープを利用して、最終的な要求の `response_type` を決定できます。 スコープの構成が `response_type` パラメーターを決定する方法の詳細については、[応答の種類のドキュメント](/docs/response-types.md)を参照してください。



## <a name="scope-types"></a>スコープの種類

`msal@1.x` に関する限り、トークン要求で構成することができる `scopes` には主に 2 つの種類があります。

### <a name="resource-scopes-for-authorization"></a>認可のリソース スコープ

`Resource scopes` は、`msal@1.x` が扱うアクセス トークン `scopes` の主な種類です。 これらは、特定のリソースに対する特定のアクションのアクセス許可を表す `scopes` です。 つまり、これらの `scopes` は、要求するアプリケーションがユーザーの代わりにアクセスすることを `authorized` するアクションとリソースを決定します。 以下は、[Microsoft Graph](https://docs.microsoft.com/en-us/graph/overview) サービスが、ユーザーの同意を得てアプリケーションを認可できる `resource scopes` の例です。

* `User.Read`:アプリケーションがユーザーのアカウント詳細を読み取ることを認可します。
* `Mail.Read`:アプリケーションがユーザーの電子メールを読み取ることを認可します。

トークン要求の構成にリソース スコープを含めることは、必ずしもそのスコープに対する **アクセス トークン** が応答に含まれることを意味するわけではありません。 `msal@1.x` の `login` API (`loginRedirect`、`loginPopup`) の特定のケースでは、リソース スコープを追加すると、ユーザーは事前にそのスコープを **承認** できる場合がありますが、`login` API 呼び出しが成功すると、**アクセス トークンではなく、ID トークン** が常に返されます。

### <a name="openid-connect-scopes-for-authentication"></a>認証の OpenID Connect スコープ

`OpenID Connect (OIDC) scopes` は、ユーザーを `authenticating` するときに要求に追加できる特定のスコープのセットです。 多くの場合、`OIDC scopes` は ID トークンに含まれる要求を構成するために追加されます ([OIDC リファレンス](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) / [Microsoft Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent#openid-connect-scopes))。 `msal@1.x` がトークンを取得する Secure Token Service など、一部のサービスでは内部ロジックで OIDC スコープを使っていることもあります。 このため、`msal@1.x` が OIDC スコープに関して持つ特別な動作 (この[次のセクション](#default-scopes-on-authorization-requests)で説明します) を理解し、注意を払うことが重要です。

`msal@1.x` が特に注意を払う OIDC スコープは、次の表で概説されています。

| OIDC スコープ | OIDC 仕様で要求される要件 | Function | OIDC リファレンス | Microsoft Docs |
| ---------- | ------------------------------ | -------- | -------------- | -------------- |
| `openid`| 必須   |  [OIDC 仕様](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest)に従って `authentication` の要求を示すメイン `OIDC scope`。 AAD 要求では、これはユーザーが承認できる "サインイン" 許可のダイアログを表示するスコープです。 | [認証の要求](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest)| [Microsoft ID プラットフォーム エンドポイントでのアクセス許可と同意](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc#send-the-sign-in-request)|
|`profile`| オプション | ID トークン `claims` の構成に使います。 返された ID トークンに要求としてエンドユーザーの既定プロファイル情報を追加します | [スコープ値を使った要求](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) | [OpenID アクセス許可](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent)|


## <a name="scopes-behavior"></a>スコープの動作

### <a name="default-scopes-on-authorization-requests"></a>認可要求の既定スコープ

`OIDC scopes` が認証応答の ID トークンに含まれる要求をどのように構成するかを理解することは、`msal@1.x` を使ってその ID トークンを取得するときに重要です。 ただし、OpenID Connect 仕様とは直接関係しない、`openid` と `profile` のスコープが `msal@1.x` によって既定ですべてのサーバー要求に追加される方法について、重要な注意事項があります。

前述のように、`msal@1.x` がアクセスおよび ID トークンを要求する Secure Token Service も `openid` および `profile` スコープを利用します。 具体的には、STS は、認可および認証応答において `client_info` パラメーターを構成して提供するために、これら 2 つのスコープが必要です。 `msal@1.x` ライブラリは、トークンを正常にキャッシュするために `client_info` のコンテンツに依存しているため、機能としてサイレント トークン取得を提供します。

**このため、開発者が要求構成に `openid` や `profile` のスコープを追加するかどうかにかかわらず、`msal@1.x` は STS に要求を送信する前にそれらが含まれていることを確認します。**

### <a name="special-oidc-scopes-behavior-cases"></a>特別な OIDC スコープの動作ケース

以下は、前のセクションで説明した既定のスコープ動作の実用的意義と例の一覧です。

- scopes 配列が `openid` または `profile` のいずれかを含まない場合、欠落している方 (両方の場合もある) は、要求を送信する前に、既定で scopes 配列に追加されます。

    例 :

    ```js
        { scopes: ['User.Read'] } // becomes { scopes: ['User.Read', 'openid', 'profile'] } before the request is sent

        { scopes: ['User.Read', 'openid'] } // becomes { scopes ['User.Read', 'openid', 'profile']} before the request is sent

        { scopes: ['User.Read', 'profile'] } // becomes { scopes ['User.Read', 'profile', 'openid']} before the request is sent

        { scopes: ['http://contoso.com/scope'] } // becomes { scopes ['http://contoso.com/scope', 'openid', 'profile'] }
    ```
- ClientId は、構成内の唯一のスコープである場合 scopes 配列から削除されます。 唯一のスコープでない場合はリソース スコープとして扱われ、最終的なサーバー要求で送信されます。

    例:
    
    ```js
        { scopes: ['YOUR_CLIENT_ID'] } // becomes { scopes: ['openid', 'profile'] } before the request is sent (ClientId is spliced out)

        { scopes: ['YOUR_CLIENT_ID', 'User.Read'] } // becomes { scopes ['YOUR_CLIENT_ID', 'User.Read', 'openid', 'profile']} before the request is sent (ClientId is treated as resource scope and therefore not spliced out)

        { scopes: ['YOUR_CLIENT_ID', 'openid'] } // becomes { scopes ['YOUR_CLIENT_ID', 'openid', 'profile']} before the request is sent
    ```