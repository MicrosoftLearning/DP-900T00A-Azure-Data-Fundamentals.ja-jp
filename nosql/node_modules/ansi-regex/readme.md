---
ms.openlocfilehash: 79b8bd5d8af7fd6d79dcb7c24b3f2e03e1d2a029
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052619"
---
# <a name="ansi-regex-build-statushttpstravis-ciorgchalkansi-regex"></a>ansi-regex [![ビルドの状況](https://travis-ci.org/chalk/ansi-regex.svg?branch=master)](https://travis-ci.org/chalk/ansi-regex)

> [ANSI エスケープ コード](http://en.wikipedia.org/wiki/ANSI_escape_code)に一致する正規表現


## <a name="install"></a>[インストール]

```
$ npm install --save ansi-regex
```


## <a name="usage"></a>使用

```js
const ansiRegex = require('ansi-regex');

ansiRegex().test('\u001b[4mcake\u001b[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\u001b[4mcake\u001b[0m'.match(ansiRegex());
//=> ['\u001b[4m', '\u001b[0m']
```

## <a name="faq"></a>よく寄せられる質問

### <a name="why-do-you-test-for-codes-not-in-the-ecma-48-standard"></a>ECMA 48 標準に含まれていないコードをテストする理由

テストとして実行するコードの一部は、標準以外のコードまたは製造元固有のコードのさまざまなリストを検索して取得したコードです。 私の記憶が正しければ、ほとんどのコードは、同じまたは同様の形式に従っており、実際の文字列の内容を削除するリスクなしに、文字列で安全に一致させることができるため、標準コードと標準以外のコードの両方をテストします。 従来の形式 (つまり数値で終わる) に従わない標準以外の制御コードがいくつか存在するため、これらを確実に一致させることができないという理由で、テストから強制的に除外することができます。

歴史的な側面では、これらの ECMA 基準が 90 年代初頭に確立されたのに対し、たとえば、VT100 は、70 年代半ばから後半にかけて設計されたものです。 その時点で、制御コードは、管理されていたとは到底言えるものではなく、実に多くの目的のために、エンジニアたちによって独自のハードウェア ポートをアクティブにするために使用されていました。 他の場所では、プロセッサの x86 アーキテクチャには、コードが同様に "無秩序" な状態で表示されます。"interrupt" は、プロセッサの特定のブランドでは意味が異なりますが、そのほとんどは、段階的に廃止されています。


## <a name="license"></a>ライセンス

MIT © [Sindre Sorhus](http://sindresorhus.com)
